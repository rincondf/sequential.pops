---
title: "Sequential testing of hypotheses about population density with the `sequential.pops` package"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Seq-vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Introduction

The `sequential.pops` package is designed to simplify the development, evaluation 
and analysis of sequential designs for testing hypotheses about population
density. Sequential analyses are particularly useful for decision-making in situations 
where estimation is not the goal, but where critical actions should be triggered if
population sizes reach or are above or below predefined levels. This situations include
deciding whether a pest control action should be applied, whether an area should be
declared free from an invasive species, or whether early capture numbers of a pest
are consistent with an outbreak. Sequential analyses can also be useful in fields 
outside ecology and pest management, such as quality control, fraud detection and
adaptive clinical trials, but those applications are out of the scope of this package.

Sequential data come in sampling bouts over time that should be processed as they come 
to evaluate one or several hypotheses and stop collecting data (sampling) when there
is enough evidence to make a decision. Sequential designs are typically more cost-efficient
than conventional fixed-sample-size approaches, and can be purely sequential (one-at-a-time)
or group sequential (`n > 1` per sampling bout). The analysis of biological population
densities is often carried out by collecting count data from traps or field observations
or binomial records from structured clusters of sampling units. The `sequential.pops`
package focuses on count and binomial data with or without overdispersion to test hypotheses
about non-negative population sizes.

There are other R packages that deal with sequential designs. Most existing
packages, such as `GroupSeq`, `Grpseq`, `gsbDesign` and `seqmon`, focus on adaptive clinical 
trials for normally distributed variables. Others, such as `gscounts`, `gsDesign`, `ASSISTant`,
`Sequential` and `BayesOrdDesign` can take non-normal variables but are also focused 
on clinical trials and can hardly be adapted to process count or binomial data from 
ecological or agricultural settings and evaluate hypotheses about population densities. 
Other packages with a more general scope, such as `MSPRT` and `sprtt`, include a limited 
selection of probability distributions and lack functions to evaluate tests' operating
characteristics.

The `sequential.pops` is the first R package devoted to test hypotheses on biological 
population densities. Two approaches are included: the Sequential Test of Bayesian
Posterior Probabilities (STBP) (Rincon et al. 2025), and the Sequential Probability
Ratio Test (SPRT) (Wald 1945). Both the STBP and the SPRT have their own pros and cons 
but are the most popular and state-of-the-art approaches for sequential analyses in 
ecology and pest management. This tutorial walks you through the development, evaluation 
and analysis of sequential designs with STBP and SPRT using the `sequential.pops`
package.

## 1. The Sequential Test of Bayesian Posterior Probabilities

This test is specifically designed to test hypotheses about population densities,
although it may have applications in other fields. It works by sequentially updating 
the conditional probability of the hypothesis being tested as new data is processed. The
two main benefits of using STBP is that is distribution-agnostic (works with virtually
any probability distribution), and that is one of the few sequential analyses that
is "likelihood ratio-free" meaning that it can test single hypotheses without having 
to specify a non-complementary alternative. As we'll see later, most sequential tests, 
such as the SPRT (section 2), require two hypotheses, rather than one, because they are based on 
likelihood ratios. Another advantage of the STBP is that it can process purely 
sequential (one-at-a-time) or group sequential (in batches of samples), balanced or 
unbalanced, and static (single-value) or dynamic (population models) hypotheses without 
major modifications. 

The main disadvantage of the STBP is that it is so new that has not been as tested as its
counterparts in the rough streets of real datasets. The STBP is also pretty sensitive to
sample sizes within sampling bouts. In theory, it outperforms other sequential analysis
as long as several samples are collected within each sampling bout, but type I error rate
(accepting H when is false) gets ugly in purely sequential designs.

### Example 1: Testing species absence

Let's start with a simple case in which one wants to test the hypothesis that certain
species is absent in sampled area. As Carl Sagan said "the absence of evidence is not 
evidence of absence". In other words, we can never be sure about the absence of an species
in an area, but we can calculate the *probability* of the species being absent *given* 
the collected data.

Most small population sizes, like those of recently introduced species, are well
described by Poisson distributions. So, in this case, we want to test if H: mu = 0
assuming random sampling and counts following a Poisson distribution. If we are lucky
and can collect say 30 random samples each time, and they all result in absences (zeros),
we should be able to track the (posterior) probability of H being true after each sampling bout
of 30.

Data structure in `sequential.pops` for counts is based on matrices, where columns
represent time (sampling bouts) and rows samples within bouts. So, for example, if we
have collected 4 sampling bouts each with 30 samples, data should be arranged in a 
`30 x 4` matrix. In this case, we have all zeros:
```{r setup}
a30 <- matrix(rep(0, 120), 30, 4)
```
To run the test, we use `stbp_simple`, which is specially designed to test hypotheses
about species absence, so we do not need to specify the hypothesis. We do need to 
provide the matrix with the `data`, the distribution family (as a character string)
in `density_func`, the initial `prior` probability (often 0.5), and `upper_criterion`
and `lower_criterion`, the upper and lower criteria to stop sampling and make a decision. 
The argument `upper_bnd` is almost always `Inf`, since it represents the upper 
limit of the parameter space for mu.
```{r}
library(sequential.pops)

test30 <- stbp_simple(data = a30,
                     density_func = "poisson",
                     prior = 0.5,
                     upper_bnd = Inf,
                     lower_criterion = 0,
                     upper_criterion = 0.9999)
test30
```
Given that all samples are zero and assuming a completely efficient detection rate,
we can say that after 3 sampling bouts of 30 samples there is a pretty high change that
H: mu = 0 is true. How spaced in time sampling bouts should be depends on the species
being sampled and on what we consider a *different* sampling time. Notice that `upper_criterion` 
and `lower_criterion` are set close to 1 and 0, respectively. In reality, to test species 
absence, only `upper_criterion` is important to minimize type II error, since the 
posterior probability of H will become 0 as soon as we get the first detection (`data > 0`).

If sample size within sampling bouts is reduced, we should expect to loose power and
require more bouts to collect enough evidence to achieve similar levels of certainty
that the species is absent (in case we keep getting zeros, of course). So, if we can
only collect 3 samples per sampling bout, and we get all zeros the matrix with the data
should be specified as:
```{r}
a3 <- matrix(rep(0, 30), 3, 10)
```
for 10 sampling bouts. After running the test with:
```{r}
test3 <- stbp_simple(data = a3,
                     density_func = "poisson",
                     prior = 0.5,
                     upper_bnd = Inf,
                     lower_criterion = 0,
                     upper_criterion = 0.9999)
test3
```
we can see that we now require 9 sampling bouts to achieve similar levels of confidence
to declare that our species is absent from the sampled area. The number of bouts with 
all zeros required to accept H keeps increasing as sampling size within bouts is reduced.
In fact, when sample size is one (purely sequential), the test looses power and the posterior 
remains unchanged regardless the number of bouts. You can check the progression of
the posterior probabilities for different sample sizes by calling `plot`, for the
sequential design with 30 samples:
```{r}
plot(test30)
```
and for the sequential design with 3 samples:
```{r}
plot(test3)
```

### Example 2: Testing if a population density is above a static threshold

The STBP can also assist in situations where one wants to test if a given population
is above or below a relevant threshold for management. This is useful to determine,
for example, if a pest population has reached an economic threshold or if an endangered 
species is below the Allee threshold. For the remaining of this tutorial, we will focus
on hypotheses about populations being *above* a threshold, but the procedure is similar 
for hypotheses with the opposite direction. In fact this is specified through a single
argument in the function `stbp_composite`.

For this example, we will use the case study of the tomato leafminer in greenhouse 
tomatoes (Rincon et al. 2021). The tomato leafminer is a significant pest of tomatoes
but prefers mostly to feed on leaves where damage is minimum and will only turn to
fruits when population density increases. The economic threshold varies depending 
on whether tomato fruits are present or not, but for now let's assume the threshold is
static (constant) at 9 larvae per plant and we want to test through sequential sampling
if a population has exceeded such threshold.

When population densities are not so small, chances are that the Poisson distribution
is no longer appropriate to describe counts and that a probability distribution a that 
allow for overdispersion (or aggregation) is required. As populations increase, very 
often they aggregate in clusters which increase the dispersion of the data to levels 
that are not accounted for by the Poisson. This is the case for the tomato leafminer, 
so the STBP should be defined with a negative binomial distribution and some specification 
for the dispersion, which is obtained from studies of the counts observed in the field. 
For more details about how to conduct these studies the reader is referred to textbooks 
like Binns et al. (2000).

Let's start by generating some negative binomial data in a purely sequential design:
```{r}
counts1 <- rnbinom(20, mu = 5, size = 4.5)
```
This is 20 random counts from a population of 5 larvae per sample unit (plant) in size 
that follows a negative binomial distribution with an overdispersion of 4.5. We can now
build a test for the hypothesis of H: mu > 9 larvae per plant with:
```{r}
test_counts1 <- stbp_composite(data = counts1,
                          greater_than = TRUE,
                          hypothesis = 9,
                          density_func = "negative binomial",
                          overdispersion = 4.5,
                          prior = 0.5,
                          lower_bnd = 0,
                          upper_bnd = Inf,
                          lower_criterion = 0.01,
                          upper_criterion = 0.99)

test_counts1
```
Notice that this time we use the function `stbp_composite`, which is designed to test
threshold-style hypotheses. The direction of the hypothesis (whether is "greater than" or
"less than") is controlled by the argument `greater_than` and the threshold is included in
the argument `hypothesis`. `lower_bnd` and `upper_bnd` are the parameter space boundaries for
the hypothesis, mu, and is almost always 0 and `Inf`, respectively. `lower_criterion` and
`upper_criterion` are the posterior probabilities above or below which a decision is
made.

Many times, however, overdispersion is not this simple and should be specified as a
function of the mean, rather than as a constant. This is the case for most animal and
plant populations because overdispersion is highly tied to the variance, and variance
of population counts tends to increase exponentially with the mean. There are several
ways to empirically describe variance (and overdispersion) as a function of the mean,
but the most popular one is Taylor's Power Law. In the `sequential.pop` package, you can
use whatever function you want, as it just must be specified before running the test.
For example, the Taylor's Power Law parameters that describe the variance-mean relationship
of tomato leafminer counts are `a = 1.83` and `b = 1.21`, so overdispersion, `k`, is
given by:
```{r}
estimate_k <- function(mean) {
                        a = 1.83
                        b = 1.21
                        (mean^2) / ((a * mean^(b)) - mean)
                        }
```
we can also incorporate more realistic values of overdispersion to the generated counts
by including `estimate_k` in the count generation function:
```{r}
counts1a <- rnbinom(20, mu = 5, size = estimate_k(5))
```
and the test can be specified as:
```{r}
test_counts1a <- stbp_composite(data = counts1a,
                          greater_than = TRUE,
                          hypothesis = 9,
                          density_func = "negative binomial",
                          overdispersion = "estimate_k",
                          prior = 0.5,
                          lower_bnd = 0,
                          upper_bnd = Inf,
                          lower_criterion = 0.01,
                          upper_criterion = 0.99)

test_counts1a
```
the overdispersion function is specified as a character string with the function name
which must be added to the R environment before running the test. Notice that the
STBP gains efficiency when an appropriate the overdispersion function is included, as
fewer samples are required to reach a decision compared with the test that assumes a
constant. 

As with `stbp_simple` you can call `plot` to visualize the change in posterior
probabilities with sequential sampling bouts for `stbp_composite` tests. 
For the test with a constant overdispersion:
```{r}
plot(test_counts1)
```
and with overdispersion as a function of the mean:
```{r}
plot(test_counts1a)
```

Sometimes data on populations do not come in counts but as binary outcomes when sampling
units are evaluated as presence/absence or infested/uninfected, for example. For those
cases, `stbp_composite` is equipped with `binomial` and `beta-binomial` options for
the argument `density_func`. Like count data, the selection of one or the other depends
on whether there is overdispersion in the data, with `beta-binomial` being the option for
overdispersed binomial variables. For these kind of data, two pieces of information are 
required from each sample unit: the number of successes (e.g., present or infected) 
and the number of samples from which observations where made. For this reason, data
for binomial variables should be structured as a `list()` of `n x 2` matrices, where
each matrix corresponds to a sampling bout, and `n` is the number of sample units (clusters 
of samples examined). The number of successes must be included in column 1 and the 
number of samples in column 2 of each matrix.

For example, if a sequential sampling is designed to collect 3 clusters (sampling units)
each made of 10 samples and 7 sampling bouts have been collected data should be 
introduced like:
```{r}
binom1 <- list()
for(i in 1: 7) {
  binom1[[i]] <- matrix(c(emdbook::rbetabinom(3, prob = 0.2, 
                                     size = 10, 
                                     theta = 6.5), rep(10, 3)),
                         3, 2)
}

binom1[1:3] # only first three sampling bouts out of seven are shown.
```
The data generated in in `binom1` is overdispersed with a constant overdispersion
parameter, `theta`. All the required support to work with the beta-binomial 
distribution is in the `emdbook` package, so it must be loaded before running any
sequential tests that involve this distribution. The STBP can be run with:
```{r}
library(emdbook)
test_bin1 <- stbp_composite(data = binom1,
                          greater_than = TRUE,
                          hypothesis = 0.15,
                          density_func = "beta-binomial",
                          overdispersion = 6.5,
                          prior = 0.5,
                          lower_bnd = 0,
                          upper_bnd = 1,
                          lower_criterion = 0.001,
                          upper_criterion = 0.999)

test_bin1
```
Like overdispersed count data, overdispersion for binomial data can also be included
as a function of the mean porportion (sometines called incidence). Again, the 
overdispersion model is derived from the variance-mean (variance-incidence) relationship,
and the most popular form is the one provided by Madden et al. (2007), although the
`sequential.pops` package allows you to pick whatever function you want. The function
that describes overdispersion, `theta`, as a function of the mean proportion for the
tomato leafminer is defined as:
```{r}
estimate_theta <- function(mean) {
  A <- 780.72
  b <- 1.61
  R <- 10
  
  (1 / (R - 1)) * (((A * R^(1 - b))/ ((mean * (1 - mean))^(1 - b))) - 1)
}
```
where `A` and `b` are parameters from the variance-incidence model and `R` is the 
number of samples in each sampling unit. We can generate a new binomial dataset
that includes variable overdispersion:
```{r}
binom2 <- list()
for(i in 1: 7) {
  binom2[[i]] <- matrix(c(rbetabinom(5, prob = 0.2, 
                                     size = 10, 
                                     theta = estimate_theta(0.2)), 
                          rep(10, 5)),
                         5, 2)
}
```
and then we can specify and run a STBP as:
```{r}
test_bin2 <- stbp_composite(data = binom2,
                          greater_than = TRUE,
                          hypothesis = 0.15,
                          density_func = "beta-binomial",
                          overdispersion = "estimate_theta",
                          prior = 0.5,
                          lower_bnd = 0,
                          upper_bnd = 1,
                          lower_criterion = 0.001,
                          upper_criterion = 0.999)

test_bin2
```
Notice that the argument `upper_bnd` in the tests `test_bin1` and `test_bin2` is set
to 1, rather than `Inf` like in the tests that processed counts, `test_counts1` and 
`test_counts1a`. This is because the parameter space of population density, mu, for
binomial data is `[0, 1]` but it is `[0, Inf]` for count data.

#### Test evaluation
