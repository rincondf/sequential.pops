<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Sequential testing of hypotheses about population density with the `sequential.pops` package • sequential.pops</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="96x96" href="../favicon-96x96.png">
<link rel="icon" type="”image/svg+xml”" href="../favicon.svg">
<link rel="apple-touch-icon" sizes="180x180" href="../apple-touch-icon.png">
<link rel="icon" sizes="any" href="../favicon.ico">
<link rel="manifest" href="../site.webmanifest">
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Sequential testing of hypotheses about population density with the `sequential.pops` package">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">sequential.pops</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.1.0</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/Seq-vignette.html">Sequential testing of hypotheses about population density with the `sequential.pops` package</a></li>
  </ul>
</li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/rincondf/sequential.pops/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.png" class="logo" alt=""><h1>Sequential testing of hypotheses about population density with the `sequential.pops` package</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/rincondf/sequential.pops/blob/master/vignettes/Seq-vignette.Rmd" class="external-link"><code>vignettes/Seq-vignette.Rmd</code></a></small>
      <div class="d-none name"><code>Seq-vignette.Rmd</code></div>
    </div>

    
    
<div class="section level2">
<h2 id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<p>The <code>sequential.pops</code> package is designed to simplify the
development, evaluation and analysis of sequential designs for testing
hypotheses about population density. Sequential analyses are
particularly useful for decision-making in situations where estimation
is not the goal, but where critical actions should be triggered if
population sizes reach or are above or below predefined levels. This
situations include deciding whether a pest control action should be
applied, whether an area should be declared free from an invasive
species, or whether early capture numbers of a pest are consistent with
an outbreak. Sequential analyses can also be useful in fields outside
ecology and pest management, such as quality control, fraud detection
and adaptive clinical trials, but those applications are out of the
scope of this package.</p>
<p>Sequential data come in sampling bouts over time that should be
processed as they come to evaluate one or several hypotheses and stop
collecting data (sampling) when there is enough evidence to make a
decision. Sequential designs are typically more cost-efficient than
conventional fixed-sample-size approaches, and can be purely sequential
(one-at-a-time) or group sequential (<code>n &gt; 1</code> per sampling
bout). The analysis of biological population densities is often carried
out by collecting count data from traps or field observations or
binomial records from structured clusters of sampling units. The
<code>sequential.pops</code> package focuses on count and binomial data
with or without overdispersion to test hypotheses about non-negative
population sizes.</p>
<p>There are other R packages that deal with sequential designs. Most
existing packages, such as <code>GroupSeq</code>, <code>Grpseq</code>,
<code>gsbDesign</code> and <code>seqmon</code>, focus on adaptive
clinical trials for normally distributed variables. Others, such as
<code>gscounts</code>, <code>gsDesign</code>, <code>ASSISTant</code>,
<code>Sequential</code> and <code>BayesOrdDesign</code> can take
non-normal variables but are also focused on clinical trials and can
hardly be adapted to process count or binomial data from ecological or
agricultural settings and evaluate hypotheses about population
densities. Other packages with a more general scope, such as
<code>MSPRT</code> and <code>sprtt</code>, include a limited selection
of probability distributions and lack functions to evaluate tests’
operating characteristics.</p>
<p>The <code>sequential.pops</code> is the first R package devoted to
test hypotheses on biological population densities. Two approaches are
included: the Sequential Test of Bayesian Posterior Probabilities (STBP)
(Rincon et al. 2025), and the Sequential Probability Ratio Test (SPRT)
(Wald 1945). Both the STBP and the SPRT have their own pros and cons but
are the most popular and state-of-the-art approaches for sequential
analyses in ecology and pest management. This tutorial walks you through
the development, evaluation and analysis of sequential designs with STBP
and SPRT using the <code>sequential.pops</code> package.</p>
</div>
<div class="section level2">
<h2 id="the-sequential-test-of-bayesian-posterior-probabilities">1. The Sequential Test of Bayesian Posterior Probabilities<a class="anchor" aria-label="anchor" href="#the-sequential-test-of-bayesian-posterior-probabilities"></a>
</h2>
<p>This test is specifically designed to test hypotheses about
population densities, although it may have applications in other fields.
It works by sequentially updating the conditional probability of the
hypothesis being tested as new data is processed. The two main benefits
of using STBP is that is distribution-agnostic (works with virtually any
probability distribution), and that is one of the few sequential
analyses that is “likelihood ratio-free” meaning that it can test single
hypotheses without having to specify a non-complementary alternative. As
we’ll see later, most sequential tests, such as the SPRT (section 2),
require two hypotheses, rather than one, because they are based on
likelihood ratios. Another advantage of the STBP is that it can process
purely sequential (one-at-a-time) or group sequential (in batches of
samples), balanced or unbalanced, and static (single-value) or dynamic
(population models) hypotheses without major modifications.</p>
<p>The main disadvantage of the STBP is that it is so new that has not
been as tested as its counterparts in the rough streets of real
datasets. The STBP is also pretty sensitive to sample sizes within
sampling bouts. In theory, it outperforms other sequential analysis as
long as several samples are collected within each sampling bout, but
type I error rate (accepting H when is false) gets ugly in purely
sequential designs.</p>
<div class="section level3">
<h3 id="example-1-testing-species-absence">Example 1: Testing species absence<a class="anchor" aria-label="anchor" href="#example-1-testing-species-absence"></a>
</h3>
<p>Let’s start with a simple case in which one wants to test the
hypothesis that certain species is absent in sampled area. As Carl Sagan
said “the absence of evidence is not evidence of absence”. In other
words, we can never be sure about the absence of an species in an area,
but we can calculate the <em>probability</em> of the species being
absent <em>given</em> the collected data.</p>
<p>Most small population sizes, like those of recently introduced
species, are well described by Poisson distributions. So, in this case,
we want to test if H: <code>mu = 0</code> assuming random sampling and
counts following a Poisson distribution. If we are lucky and can collect
say 30 random samples each time, and they all result in absences
(zeros), we should be able to track the (posterior) probability of H
being true after each sampling bout of 30.</p>
<p>Data structure in <code>sequential.pops</code> for counts is based on
matrices, where columns represent time (sampling bouts) and rows samples
within bouts. So, for example, if we have collected 4 sampling bouts
each with 30 samples, data should be arranged in a <code>30 x 4</code>
matrix. In this case, we have all zeros:</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">a30</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">120</span><span class="op">)</span>, <span class="fl">30</span>, <span class="fl">4</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">a30</span>, <span class="fl">3</span><span class="op">)</span> <span class="co"># only first three rows out of 30 are shown</span></span>
<span><span class="co">#&gt;      [,1] [,2] [,3] [,4]</span></span>
<span><span class="co">#&gt; [1,]    0    0    0    0</span></span>
<span><span class="co">#&gt; [2,]    0    0    0    0</span></span>
<span><span class="co">#&gt; [3,]    0    0    0    0</span></span></code></pre></div>
<p>To run the test, we use <code>stbp_simple</code>, which is specially
designed to test hypotheses about species absence, so we do not need to
specify the hypothesis. We do need to provide the matrix with the
<code>data</code>, the distribution family (as a character string) in
<code>density_func</code>, the initial <code>prior</code> probability
(often 0.5), and <code>upper_criterion</code> and
<code>lower_criterion</code>, the upper and lower criteria to stop
sampling and make a decision. The argument <code>upper_bnd</code> is
almost always <code>Inf</code>, since it represents the upper limit of
the parameter space for <code>mu</code>.</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/rincondf/sequential.pops" class="external-link">sequential.pops</a></span><span class="op">)</span></span>
<span></span>
<span><span class="va">test30</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/stbp_simple.html">stbp_simple</a></span><span class="op">(</span>data <span class="op">=</span> <span class="va">a30</span>,</span>
<span>                      density_func <span class="op">=</span> <span class="st">"poisson"</span>,</span>
<span>                      prior <span class="op">=</span> <span class="fl">0.5</span>,</span>
<span>                      upper_bnd <span class="op">=</span> <span class="cn">Inf</span>,</span>
<span>                      lower_criterion <span class="op">=</span> <span class="fl">0</span>,</span>
<span>                      upper_criterion <span class="op">=</span> <span class="fl">0.9999</span><span class="op">)</span></span>
<span><span class="va">test30</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Sequential test of Bayesian posterior probabilities</span></span>
<span><span class="co">#&gt; Family: poisson</span></span>
<span><span class="co">#&gt; H: mu = 0</span></span>
<span><span class="co">#&gt; Probability: 0.99996 from 3 sampling bouts</span></span>
<span><span class="co">#&gt; Recommendation based on provided criteria: accept H</span></span></code></pre></div>
<p>Given that all samples are zero and assuming a completely efficient
detection rate, we can say that after 3 sampling bouts of 30 samples
there is a pretty high change that H: <code>mu = 0</code> is true. How
spaced in time sampling bouts should be depends on the species being
sampled and on what we consider a <em>different</em> sampling time.
Notice that <code>upper_criterion</code> and
<code>lower_criterion</code> are set close to 1 and 0, respectively. In
reality, to test species absence, only <code>upper_criterion</code> is
important to minimize type II error, since the posterior probability of
H will become 0 as soon as we get the first detection
(<code>data &gt; 0</code>).</p>
<p>If sample size within sampling bouts is reduced, we should expect to
loose power and require more bouts to collect enough evidence to achieve
similar levels of certainty that the species is absent (in case we keep
getting zeros, of course). So, if we can only collect 3 samples per
sampling bout, and we get all zeros the matrix with the data should be
specified as:</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">a3</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">30</span><span class="op">)</span>, <span class="fl">3</span>, <span class="fl">10</span><span class="op">)</span></span>
<span><span class="va">a3</span></span>
<span><span class="co">#&gt;      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]</span></span>
<span><span class="co">#&gt; [1,]    0    0    0    0    0    0    0    0    0     0</span></span>
<span><span class="co">#&gt; [2,]    0    0    0    0    0    0    0    0    0     0</span></span>
<span><span class="co">#&gt; [3,]    0    0    0    0    0    0    0    0    0     0</span></span></code></pre></div>
<p>for 10 sampling bouts. After running the test with:</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">test3</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/stbp_simple.html">stbp_simple</a></span><span class="op">(</span>data <span class="op">=</span> <span class="va">a3</span>,</span>
<span>                     density_func <span class="op">=</span> <span class="st">"poisson"</span>,</span>
<span>                     prior <span class="op">=</span> <span class="fl">0.5</span>,</span>
<span>                     upper_bnd <span class="op">=</span> <span class="cn">Inf</span>,</span>
<span>                     lower_criterion <span class="op">=</span> <span class="fl">0</span>,</span>
<span>                     upper_criterion <span class="op">=</span> <span class="fl">0.9999</span><span class="op">)</span></span>
<span><span class="va">test3</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Sequential test of Bayesian posterior probabilities</span></span>
<span><span class="co">#&gt; Family: poisson</span></span>
<span><span class="co">#&gt; H: mu = 0</span></span>
<span><span class="co">#&gt; Probability: 0.99995 from 9 sampling bouts</span></span>
<span><span class="co">#&gt; Recommendation based on provided criteria: accept H</span></span></code></pre></div>
<p>we can see that we now require 9 sampling bouts to achieve similar
levels of confidence to declare that our species is absent from the
sampled area. The number of bouts with all zeros required to accept H
keeps increasing as sampling size within bouts is reduced. In fact, when
sample size is one (purely sequential), the test looses power and the
posterior remains unchanged regardless the number of bouts. You can
check the progression of the posterior probabilities for different
sample sizes by calling <code>plot</code>, for the sequential design
with 30 samples:</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/plot-STBP-missing-method.html">plot</a></span><span class="op">(</span><span class="va">test30</span><span class="op">)</span></span></code></pre></div>
<p><img src="Seq-vignette_files/figure-html/unnamed-chunk-5-1.png" width="700"></p>
<p>and for the sequential design with 3 samples:</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/plot-STBP-missing-method.html">plot</a></span><span class="op">(</span><span class="va">test3</span><span class="op">)</span></span></code></pre></div>
<p><img src="Seq-vignette_files/figure-html/unnamed-chunk-6-1.png" width="700"></p>
</div>
<div class="section level3">
<h3 id="example-2-testing-if-a-population-is-above-a-static-threshold">Example 2: Testing if a population is above a static threshold<a class="anchor" aria-label="anchor" href="#example-2-testing-if-a-population-is-above-a-static-threshold"></a>
</h3>
<p>The STBP can also assist in situations where one wants to test if a
given population is above or below a relevant threshold for management.
This is useful to determine, for example, if a pest population has
reached an economic threshold or if an endangered species is below the
Allee threshold. For the remaining of this tutorial, we will focus on
hypotheses about populations being <em>above</em> a threshold, but the
procedure is similar for hypotheses with the opposite direction. In fact
this is specified through a single argument in the function
<code>stbp_composite</code>.</p>
<p>For this example, we will use the case study of the tomato leafminer
in greenhouse tomatoes (Rincon et al. 2021). The tomato leafminer is a
significant pest of tomatoes but prefers mostly to feed on leaves where
damage is minimum and will only turn to fruits when population density
increases. The economic threshold varies depending on whether tomato
fruits are present or not, but for now let’s assume the threshold is
static (constant) at 9 larvae per plant and we want to test through
sequential sampling if a population has exceeded such threshold.</p>
<p>When population densities are not so small, chances are that the
Poisson distribution is no longer appropriate to describe counts and
that a probability distribution a that allow for overdispersion (or
aggregation) is required. As populations increase, very often they
aggregate in clusters which increase the dispersion of the data to
levels that are not accounted for by the Poisson. This is the case for
the tomato leafminer, so the STBP should be defined with a negative
binomial distribution and some specification for the dispersion, which
is obtained from studies of the counts observed in the field. For more
details about how to conduct these studies the reader is referred to
textbooks like Binns et al. (2000).</p>
<p>Let’s start by generating some negative binomial data in a purely
sequential design (<code>n = 1</code> per sampling bout):</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">counts1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/NegBinomial.html" class="external-link">rnbinom</a></span><span class="op">(</span><span class="fl">20</span>, mu <span class="op">=</span> <span class="fl">5</span>, size <span class="op">=</span> <span class="fl">4.5</span><span class="op">)</span></span>
<span><span class="va">counts1</span></span>
<span><span class="co">#&gt;  [1] 7 3 9 3 4 4 4 4 6 3 4 3 5 1 4 5 2 9 4 1</span></span></code></pre></div>
<p>This is 20 random counts from a population of 5 larvae per sample
unit (plant) in size that follows a negative binomial distribution with
an overdispersion of 4.5. We can now build a test for the hypothesis of
H: <code>mu &gt; 9</code> larvae per plant with:</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">test_counts1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/stbp_composite.html">stbp_composite</a></span><span class="op">(</span>data <span class="op">=</span> <span class="va">counts1</span>,</span>
<span>                               greater_than <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>                               hypothesis <span class="op">=</span> <span class="fl">9</span>,</span>
<span>                               density_func <span class="op">=</span> <span class="st">"negative binomial"</span>,</span>
<span>                               overdispersion <span class="op">=</span> <span class="fl">4.5</span>,</span>
<span>                               prior <span class="op">=</span> <span class="fl">0.5</span>,</span>
<span>                               lower_bnd <span class="op">=</span> <span class="fl">0</span>,</span>
<span>                               upper_bnd <span class="op">=</span> <span class="cn">Inf</span>,</span>
<span>                               lower_criterion <span class="op">=</span> <span class="fl">0.01</span>,</span>
<span>                               upper_criterion <span class="op">=</span> <span class="fl">0.99</span><span class="op">)</span></span>
<span><span class="va">test_counts1</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Sequential test of Bayesian posterior probabilities</span></span>
<span><span class="co">#&gt; Family: negative binomial</span></span>
<span><span class="co">#&gt; H: mu &gt; 9</span></span>
<span><span class="co">#&gt; Probability: 0.00548 from 11 sampling bouts</span></span>
<span><span class="co">#&gt; Recommendation based on provided criteria: reject H</span></span></code></pre></div>
<p>Notice that this time we use the function
<code>stbp_composite</code>, which is designed to test threshold-style
hypotheses. The direction of the hypothesis (whether is “greater than”
or “less than”) is controlled by the argument <code>greater_than</code>
and the threshold is included in the argument <code>hypothesis</code>.
<code>lower_bnd</code> and <code>upper_bnd</code> are the parameter
space boundaries for the hypothesis, <code>mu</code>, and is almost
always 0 and <code>Inf</code>, respectively.
<code>lower_criterion</code> and <code>upper_criterion</code> are the
posterior probabilities above or below which a decision is made.</p>
<p>Many times, however, overdispersion is not this simple and should be
specified as a function of the mean, rather than as a constant. This is
the case for most animal and plant populations because overdispersion is
highly tied to the variance, and variance of population counts tends to
increase exponentially with the mean. There are several ways to
empirically describe variance (and overdispersion) as a function of the
mean, but the most popular one is Taylor’s Power Law. In the
<code>sequential.pop</code> package, you can use whatever function you
want, as it just must be specified before running the test. For example,
the Taylor’s Power Law parameters that describe the variance-mean
relationship of tomato leafminer counts are <code>a = 1.83</code> and
<code>b = 1.21</code>, so overdispersion, <code>k</code>, is given
by:</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">estimate_k</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">mean</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">a</span> <span class="op">=</span> <span class="fl">1.83</span> </span>
<span>  <span class="va">b</span> <span class="op">=</span> <span class="fl">1.21</span></span>
<span>  </span>
<span>  <span class="op">(</span><span class="va">mean</span><span class="op">^</span><span class="fl">2</span><span class="op">)</span> <span class="op">/</span> <span class="op">(</span><span class="op">(</span><span class="va">a</span> <span class="op">*</span> <span class="va">mean</span><span class="op">^</span><span class="op">(</span><span class="va">b</span><span class="op">)</span><span class="op">)</span> <span class="op">-</span> <span class="va">mean</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>we can also incorporate more realistic values of overdispersion to
the generated counts by including <code>estimate_k</code> in the count
generation function:</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">counts1a</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/NegBinomial.html" class="external-link">rnbinom</a></span><span class="op">(</span><span class="fl">20</span>, mu <span class="op">=</span> <span class="fl">5</span>, size <span class="op">=</span> <span class="fu">estimate_k</span><span class="op">(</span><span class="fl">5</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">counts1a</span></span>
<span><span class="co">#&gt;  [1] 10  6 10 12  2  4 10  6  0  5  5  4  3  2  1 10  5  2  4  4</span></span></code></pre></div>
<p>and the test can be specified as:</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">test_counts1a</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/stbp_composite.html">stbp_composite</a></span><span class="op">(</span>data <span class="op">=</span> <span class="va">counts1a</span>,</span>
<span>                                greater_than <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>                                hypothesis <span class="op">=</span> <span class="fl">9</span>,</span>
<span>                                density_func <span class="op">=</span> <span class="st">"negative binomial"</span>,</span>
<span>                                overdispersion <span class="op">=</span> <span class="st">"estimate_k"</span>,</span>
<span>                                prior <span class="op">=</span> <span class="fl">0.5</span>,</span>
<span>                                lower_bnd <span class="op">=</span> <span class="fl">0</span>,</span>
<span>                                upper_bnd <span class="op">=</span> <span class="cn">Inf</span>,</span>
<span>                                lower_criterion <span class="op">=</span> <span class="fl">0.01</span>,</span>
<span>                                upper_criterion <span class="op">=</span> <span class="fl">0.99</span><span class="op">)</span></span>
<span><span class="va">test_counts1a</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Sequential test of Bayesian posterior probabilities</span></span>
<span><span class="co">#&gt; Family: negative binomial</span></span>
<span><span class="co">#&gt; H: mu &gt; 9</span></span>
<span><span class="co">#&gt; Probability: 0.00949 from 11 sampling bouts</span></span>
<span><span class="co">#&gt; Recommendation based on provided criteria: reject H</span></span></code></pre></div>
<p>the overdispersion function is specified as a character string with
the function name which must be added to the R environment before
running the test. Although it is not the case for this instance of
randomly generated numbers, there are noticeable gains in efficiency
(fewer average number of sampling bouts to make a decision) and accuracy
(less bad decisions) when an appropriate the overdispersion function is
included as part of a STBP (Rincon et al. 2025).</p>
<p>As with <code>stbp_simple</code> you can call <code>plot</code> to
visualize the change in posterior probabilities with sequential sampling
bouts for <code>stbp_composite</code> tests. For the test with a
constant overdispersion:</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/plot-STBP-missing-method.html">plot</a></span><span class="op">(</span><span class="va">test_counts1</span><span class="op">)</span></span></code></pre></div>
<p><img src="Seq-vignette_files/figure-html/unnamed-chunk-12-1.png" width="700"></p>
<p>and with overdispersion as a function of the mean:</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/plot-STBP-missing-method.html">plot</a></span><span class="op">(</span><span class="va">test_counts1a</span><span class="op">)</span></span></code></pre></div>
<p><img src="Seq-vignette_files/figure-html/unnamed-chunk-13-1.png" width="700"></p>
<p>Sometimes data on populations do not come in counts but as binary
outcomes when sampling units are evaluated as presence/absence or
infested/uninfected, for example. For those cases,
<code>stbp_composite</code> is equipped with <code>binomial</code> and
<code>beta-binomial</code> options for the argument
<code>density_func</code>. Like count data, the selection of one or the
other depends on whether there is overdispersion in the data, with
<code>beta-binomial</code> being the option for overdispersed binomial
variables. For these kind of data, two pieces of information are
required from each sample unit: the number of successes (e.g., present
or infected) and the total number of samples from which observations
where made. For this reason, data for binomial variables should be
structured as a <code><a href="https://rdrr.io/r/base/list.html" class="external-link">list()</a></code> of <code>n x 2</code> matrices,
where each matrix corresponds to a sampling bout, and <code>n</code> is
the number of sample units (clusters of samples examined). The number of
successes must be included in column 1 and the number of samples in
column 2 of each matrix.</p>
<p>For example, if a sequential sampling is designed to collect 3
clusters (sampling units) each made of 10 samples and 7 sampling bouts
have been collected data should be introduced like:</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://www.math.mcmaster.ca/bolker/emdbook" class="external-link">emdbook</a></span><span class="op">)</span> <span class="co"># for rbetabinom()</span></span>
<span></span>
<span><span class="va">binom1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="op">)</span></span>
<span><span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span> <span class="fl">7</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">binom1</span><span class="op">[[</span><span class="va">i</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fu">emdbook</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/emdbook/man/dbetabinom.html" class="external-link">rbetabinom</a></span><span class="op">(</span><span class="fl">3</span>, prob <span class="op">=</span> <span class="fl">0.2</span>,</span>
<span>                                              size <span class="op">=</span> <span class="fl">10</span>,</span>
<span>                                              theta <span class="op">=</span> <span class="fl">6.5</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">10</span>, <span class="fl">3</span><span class="op">)</span><span class="op">)</span>, <span class="fl">3</span>, <span class="fl">2</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">binom1</span>, <span class="fl">3</span><span class="op">)</span> <span class="co"># only first three sampling bouts out of seven are shown.</span></span>
<span><span class="co">#&gt; [[1]]</span></span>
<span><span class="co">#&gt;      [,1] [,2]</span></span>
<span><span class="co">#&gt; [1,]    1   10</span></span>
<span><span class="co">#&gt; [2,]    0   10</span></span>
<span><span class="co">#&gt; [3,]    1   10</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[2]]</span></span>
<span><span class="co">#&gt;      [,1] [,2]</span></span>
<span><span class="co">#&gt; [1,]    2   10</span></span>
<span><span class="co">#&gt; [2,]    6   10</span></span>
<span><span class="co">#&gt; [3,]    0   10</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[3]]</span></span>
<span><span class="co">#&gt;      [,1] [,2]</span></span>
<span><span class="co">#&gt; [1,]    0   10</span></span>
<span><span class="co">#&gt; [2,]    6   10</span></span>
<span><span class="co">#&gt; [3,]    6   10</span></span></code></pre></div>
<p>The data generated in the list <code>binom1</code> is overdispersed
with a constant overdispersion parameter, <code>theta</code> and mean
incidence of <code>prob = 0.2</code>. All the required support to work
with the beta-binomial distribution is in the <code>emdbook</code>
package, so it must be loaded before running any sequential tests that
involve this distribution. The STBP can be run on the data
<code>binom1</code> with:</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">test_bin1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/stbp_composite.html">stbp_composite</a></span><span class="op">(</span>data <span class="op">=</span> <span class="va">binom1</span>,</span>
<span>                            greater_than <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>                            hypothesis <span class="op">=</span> <span class="fl">0.15</span>,</span>
<span>                            density_func <span class="op">=</span> <span class="st">"beta-binomial"</span>,</span>
<span>                            overdispersion <span class="op">=</span> <span class="fl">6.5</span>,</span>
<span>                            prior <span class="op">=</span> <span class="fl">0.5</span>,</span>
<span>                            lower_bnd <span class="op">=</span> <span class="fl">0</span>,</span>
<span>                            upper_bnd <span class="op">=</span> <span class="fl">1</span>,</span>
<span>                            lower_criterion <span class="op">=</span> <span class="fl">0.001</span>,</span>
<span>                            upper_criterion <span class="op">=</span> <span class="fl">0.999</span><span class="op">)</span></span>
<span><span class="va">test_bin1</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Sequential test of Bayesian posterior probabilities</span></span>
<span><span class="co">#&gt; Family: beta-binomial</span></span>
<span><span class="co">#&gt; H: mu &gt; 0.15</span></span>
<span><span class="co">#&gt; Probability: 0.99999 from 4 sampling bouts</span></span>
<span><span class="co">#&gt; Recommendation based on provided criteria: accept H</span></span></code></pre></div>
<p>where the STBP correctly infers that the data in <code>binom1</code>
is consistent with H: <code>mu &gt; 0.15</code>. Like overdispersed
count data, overdispersion for binomial data can also be included as a
function of mean proportion (sometines called incidence). Again, the
overdispersion model is derived from the variance-mean
(variance-incidence) relationship, and the most popular form is the one
provided by Madden et al. (2007), although the
<code>sequential.pops</code> package allows you to pick whatever
function you want. The function that describes overdispersion,
<code>theta</code>, as a function of the mean proportion for the tomato
leafminer is defined as (Madden et al. 2007):</p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">estimate_theta</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">mean</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">A</span> <span class="op">=</span> <span class="fl">780.72</span></span>
<span>  <span class="va">b</span> <span class="op">=</span> <span class="fl">1.61</span></span>
<span>  <span class="va">R</span> <span class="op">=</span> <span class="fl">10</span></span>
<span>  </span>
<span>  <span class="op">(</span><span class="fl">1</span> <span class="op">/</span> <span class="op">(</span><span class="va">R</span> <span class="op">-</span> <span class="fl">1</span><span class="op">)</span><span class="op">)</span> <span class="op">*</span> <span class="op">(</span><span class="op">(</span><span class="op">(</span><span class="va">A</span> <span class="op">*</span> <span class="va">R</span><span class="op">^</span><span class="op">(</span><span class="fl">1</span> <span class="op">-</span> <span class="va">b</span><span class="op">)</span><span class="op">)</span><span class="op">/</span> <span class="op">(</span><span class="op">(</span><span class="va">mean</span> <span class="op">*</span> <span class="op">(</span><span class="fl">1</span> <span class="op">-</span> <span class="va">mean</span><span class="op">)</span><span class="op">)</span><span class="op">^</span><span class="op">(</span><span class="fl">1</span> <span class="op">-</span> <span class="va">b</span><span class="op">)</span><span class="op">)</span><span class="op">)</span> <span class="op">-</span> <span class="fl">1</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>where <code>A</code> and <code>b</code> are parameters from the
variance-incidence model and <code>R</code> is the number of samples in
each sampling unit (cluster). We can generate a new binomial dataset
that includes variable overdispersion:</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">binom2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html" class="external-link">list</a></span><span class="op">(</span><span class="op">)</span></span>
<span><span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span> <span class="fl">7</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">binom2</span><span class="op">[[</span><span class="va">i</span><span class="op">]</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/pkg/emdbook/man/dbetabinom.html" class="external-link">rbetabinom</a></span><span class="op">(</span><span class="fl">3</span>, prob <span class="op">=</span> <span class="fl">0.2</span>,</span>
<span>                                     size <span class="op">=</span> <span class="fl">10</span>,</span>
<span>                                     theta <span class="op">=</span> <span class="fu">estimate_theta</span><span class="op">(</span><span class="fl">0.2</span><span class="op">)</span><span class="op">)</span>,</span>
<span>                          <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">10</span>, <span class="fl">3</span><span class="op">)</span><span class="op">)</span>, <span class="fl">3</span>, <span class="fl">2</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">binom2</span>, <span class="fl">3</span><span class="op">)</span> <span class="co"># only first three sampling bouts out of seven are shown.</span></span>
<span><span class="co">#&gt; [[1]]</span></span>
<span><span class="co">#&gt;      [,1] [,2]</span></span>
<span><span class="co">#&gt; [1,]    1   10</span></span>
<span><span class="co">#&gt; [2,]    2   10</span></span>
<span><span class="co">#&gt; [3,]    1   10</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[2]]</span></span>
<span><span class="co">#&gt;      [,1] [,2]</span></span>
<span><span class="co">#&gt; [1,]    3   10</span></span>
<span><span class="co">#&gt; [2,]    4   10</span></span>
<span><span class="co">#&gt; [3,]    1   10</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; [[3]]</span></span>
<span><span class="co">#&gt;      [,1] [,2]</span></span>
<span><span class="co">#&gt; [1,]    2   10</span></span>
<span><span class="co">#&gt; [2,]    4   10</span></span>
<span><span class="co">#&gt; [3,]    2   10</span></span></code></pre></div>
<p>and then we can specify and run a STBP as:</p>
<div class="sourceCode" id="cb18"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">test_bin2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/stbp_composite.html">stbp_composite</a></span><span class="op">(</span>data <span class="op">=</span> <span class="va">binom2</span>,</span>
<span>                            greater_than <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>                            hypothesis <span class="op">=</span> <span class="fl">0.15</span>,</span>
<span>                            density_func <span class="op">=</span> <span class="st">"beta-binomial"</span>,</span>
<span>                            overdispersion <span class="op">=</span> <span class="st">"estimate_theta"</span>,</span>
<span>                            prior <span class="op">=</span> <span class="fl">0.5</span>,</span>
<span>                            lower_bnd <span class="op">=</span> <span class="fl">0</span>,</span>
<span>                            upper_bnd <span class="op">=</span> <span class="fl">1</span>,</span>
<span>                            lower_criterion <span class="op">=</span> <span class="fl">0.001</span>,</span>
<span>                            upper_criterion <span class="op">=</span> <span class="fl">0.999</span><span class="op">)</span></span>
<span><span class="va">test_bin2</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Sequential test of Bayesian posterior probabilities</span></span>
<span><span class="co">#&gt; Family: beta-binomial</span></span>
<span><span class="co">#&gt; H: mu &gt; 0.15</span></span>
<span><span class="co">#&gt; Probability: 0.99935 from 3 sampling bouts</span></span>
<span><span class="co">#&gt; Recommendation based on provided criteria: accept H</span></span></code></pre></div>
<p>Notice that the argument <code>upper_bnd</code> in the tests
<code>test_bin1</code> and <code>test_bin2</code> is set to 1, rather
than <code>Inf</code> like in the tests that processed counts,
<code>test_counts1</code> and <code>test_counts1a</code>. This is
because the parameter space of population density, <code>mu</code>, for
binomial data is <code>[0, 1]</code> but it is <code>[0, Inf]</code> for
count data.</p>
<div class="section level4">
<h4 id="test-evaluation">Test evaluation<a class="anchor" aria-label="anchor" href="#test-evaluation"></a>
</h4>
<p>The <code>sequential.pops</code> package is equipped with tools to
evaluate the accuracy and efficiency of specifications for the STBP. For
a perfectly accurate sequential test, the acceptance rates of H:
<code>mu &gt; psi</code> are zero when the true population is &lt; psi
and 1 when it is &gt; psi, with a minimum (efficient) average number of
samples. Thus, the evaluation of STBP involves the analysis of the
proportion of times H is accepted across a range of true population
densities and the corresponding number of sampling bouts required to
make a decision. Sometimes these analyses are called “operating
characteristics”.</p>
<p>All you need to run an evaluation of a STBP is a <code>STBP</code>
object, which is created every time a test is run through
<code>stbp_composite</code>, an evaluation range, which is a sequence of
population densities over which the evaluation is to be performed, and
the sample size within bouts. You can add additional levels of
sophistication by playing with the initial prior probability or by
adding stochasticity to the overdipersion parameter, in case you are
using one.</p>
<p>To demonstrate the evaluation of STBP we will use the
<code>STBP</code> objects created above. The simplest one is
<code>test_counts1</code>, which is a purely sequential design that
tests H: <code>mu &gt; 9</code> with constant overdispersion of
<code>k = 4.5</code>. For the evaluation, the only relevant information
that is extracted from <code>test_counts1</code> has to do with the test
specification, and the data is not really used. To run evaluation of
<code>test_counts1</code> we call the function
<code>STBP.eval</code>:</p>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">eval1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/STBP.eval.html">STBP.eval</a></span><span class="op">(</span><span class="va">test_counts1</span>,</span>
<span>                   eval.range <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">3</span>, <span class="fl">12</span><span class="op">)</span>,</span>
<span>                   n <span class="op">=</span> <span class="fl">1</span>,</span>
<span>                   prior <span class="op">=</span> <span class="fl">0.5</span>,</span>
<span>                   N <span class="op">=</span> <span class="fl">20</span><span class="op">)</span></span>
<span><span class="va">eval1</span></span>
<span><span class="co">#&gt; $AvgSamples</span></span>
<span><span class="co">#&gt;  [1]  4.05  5.60  9.75 14.05 10.20  7.95  6.15  5.70  3.95  3.15</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; $AcceptRate</span></span>
<span><span class="co">#&gt;  [1] 0.00 0.00 0.05 0.50 0.85 1.00 1.00 1.00 1.00 1.00</span></span></code></pre></div>
<p>Notice that the evaluation range of true population densities
(<code>eval.range</code>) includes psi, the threshold (hypothesis),
because we are particularly interested in examining the behavior of the
test when population size is close the threshold. Also, that the purely
sequential approach was kept for this analysis (<code>n = 1</code>), but
we could also try other samples sizes. The argument <code>N</code> is
the number of simulations run for each true population size. In this
case is 20, so a total of 200 simulations were run
(<code>20 * length(seq(3, 12))</code>), which is pretty small for a
formal analysis. You should run, at least, 1000 simulation per
population size in more formal test.</p>
<p>The output of <code>STBP.eval</code> is a <code><a href="https://rdrr.io/r/base/list.html" class="external-link">list()</a></code> with
two vectors: <code>$AvgSamples</code> and <code>$AcceptRate</code>. Both
have as many elements as <code>length(eval.range)</code> and the first
is the mean number of sampling bouts required to make a decision about H
and the second is the proportion of simulation runs that resulted in
acceptance of H. Both can be visualized across the evaluated range of
true population densities to the test performance around the threshold
of 9:</p>
<div class="sourceCode" id="cb20"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/plot-STBP-missing-method.html">plot</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">3</span>, <span class="fl">12</span><span class="op">)</span>, <span class="va">eval1</span><span class="op">$</span><span class="va">AvgSamples</span>, type <span class="op">=</span> <span class="st">"o"</span>, xlab <span class="op">=</span> <span class="st">"True population size"</span>,</span>
<span>      ylab <span class="op">=</span> <span class="st">"Average number of bouts"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/abline.html" class="external-link">abline</a></span><span class="op">(</span>v <span class="op">=</span> <span class="fl">9</span>, lty <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<p><img src="Seq-vignette_files/figure-html/unnamed-chunk-20-1.png" width="700"></p>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span></span>
<span><span class="fu"><a href="../reference/plot-STBP-missing-method.html">plot</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">3</span>, <span class="fl">12</span><span class="op">)</span>, <span class="va">eval1</span><span class="op">$</span><span class="va">AcceptRate</span>, type <span class="op">=</span> <span class="st">"o"</span>, xlab <span class="op">=</span> <span class="st">"True population size"</span>,</span>
<span>      ylab <span class="op">=</span> <span class="st">"Acceptance rate of H"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/abline.html" class="external-link">abline</a></span><span class="op">(</span>v <span class="op">=</span> <span class="fl">9</span>, lty <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<p><img src="Seq-vignette_files/figure-html/unnamed-chunk-20-2.png" width="700"></p>
<p>There is an argument in the <code>STBP.eval</code> function called
<code>overdispersion.sim</code> that was omitted in <code>eval1</code>.
Through <code>overdispersion.sim</code>, you can specify overdispersion
functions or values different from those specified in the test. So, in
<code>eval1</code>, the overdispersion used to run the simulations was
the same as in the test <code>test_counts1</code>. However, more
realistic test evaluations can be performed if (1) varying
overdispersion is included and (2) stochasticity about the variance-mean
relationship is considered. The first can either be specified in the
model (as in <code>test_counts1a</code> or in <code>test_bin2</code>) or
directly in <code>STBP.eval</code> through
<code>overdispersion.sim</code>, in case is not in the model.</p>
<p>To add stochasticity, however, you should declare a new
overdispersion function with allowance for variability. This new
function is similar to the one used for the models but includes a random
normal variable with <code>mean = 0</code> and standard deviation
<code>sd</code> as a new factor. Conventionally, <code>sd</code> is the
square root of the mean square error for the regression used to fit the
variance-mean model: Taylor’s Power Law, for count data, and Madden’s
model for binomial data (Binns et al. 2000).</p>
<p>For example, if we want to add stochasticity to the evaluation of
model <code>test_counts1a</code>, we should incorporate a normal random
variable in function <code>estimate_k</code> by:</p>
<div class="sourceCode" id="cb22"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">estimate_k_stoch</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">mean</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">a</span> <span class="op">=</span> <span class="fl">1.83</span></span>
<span>  <span class="va">b</span> <span class="op">=</span> <span class="fl">1.21</span></span>
<span>  <span class="va">RMSE</span> <span class="op">=</span> <span class="fl">0.32</span></span>
<span>  </span>
<span>  <span class="op">(</span><span class="va">mean</span><span class="op">^</span><span class="fl">2</span><span class="op">)</span> <span class="op">/</span> </span>
<span>    <span class="op">(</span><span class="op">(</span><span class="va">a</span> <span class="op">*</span> <span class="va">mean</span><span class="op">^</span><span class="op">(</span><span class="va">b</span><span class="op">)</span> <span class="op">*</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">exp</a></span><span class="op">(</span><span class="fu">truncdist</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/truncdist/man/rtrunc.html" class="external-link">rtrunc</a></span><span class="op">(</span><span class="fl">1</span>, <span class="st">"norm"</span>, </span>
<span>                                           a <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">log</a></span><span class="op">(</span><span class="fl">1</span> <span class="op">/</span> <span class="op">(</span><span class="va">a</span> <span class="op">*</span> <span class="va">mean</span><span class="op">^</span><span class="op">(</span><span class="va">b</span> <span class="op">-</span> <span class="fl">1</span><span class="op">)</span><span class="op">)</span><span class="op">)</span>, </span>
<span>                                           b <span class="op">=</span> <span class="cn">Inf</span>, </span>
<span>                                           mean <span class="op">=</span> <span class="fl">0</span>, </span>
<span>                                           sd <span class="op">=</span> <span class="va">RMSE</span><span class="op">)</span><span class="op">)</span><span class="op">)</span> </span>
<span>     <span class="op">-</span> <span class="va">mean</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>Notice that <code>estimate_k_stoch</code> is similar to
<code>estimate_k</code> except that the former includes the exponential
of a normal random variable as a factor in the denominator. Here we use
a truncated normal distribution, form the <code>truncdist</code>
package, to prevent zero denominators or negative values for
<code>k</code>, but you can also use <code>rnorm</code> and a different
alternative to stay away from undefined or negative values for the
overdispersion parameter. To run the evaluation including stochasticity,
we just specify <code>estimate_stoch</code> as a character string in the
argument <code>overdispersion.sim</code>.</p>
<div class="sourceCode" id="cb23"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">eval1a</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/STBP.eval.html">STBP.eval</a></span><span class="op">(</span><span class="va">test_counts1</span>,</span>
<span>                    eval.range <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">3</span>, <span class="fl">12</span><span class="op">)</span>,</span>
<span>                    n <span class="op">=</span> <span class="fl">1</span>,</span>
<span>                    prior <span class="op">=</span> <span class="fl">0.5</span>,</span>
<span>                    overdispersion.sim <span class="op">=</span> <span class="st">"estimate_k_stoch"</span>,</span>
<span>                    N <span class="op">=</span> <span class="fl">20</span><span class="op">)</span></span>
<span><span class="va">eval1a</span></span>
<span><span class="co">#&gt; $AvgSamples</span></span>
<span><span class="co">#&gt;  [1]  3.40  5.50  7.65 11.40 12.50  6.20  6.50  4.30  4.10  3.35</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; $AcceptRate</span></span>
<span><span class="co">#&gt;  [1] 0.05 0.00 0.20 0.40 0.75 0.85 1.00 1.00 1.00 1.00</span></span></code></pre></div>
<p>Test evaluation is a useful tool to compare different sequential
analysis approaches, but it can also be useful to calibrate sample size,
decision criteria or the impact of (incorrect) initial priors of
sequential designs. For example, you can compare both accuracy and
efficiency of tests with different sample sizes within bouts.</p>
<div class="sourceCode" id="cb24"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">eval3a</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/STBP.eval.html">STBP.eval</a></span><span class="op">(</span><span class="va">test_counts1</span>,</span>
<span>                    eval.range <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">3</span>, <span class="fl">12</span><span class="op">)</span>,</span>
<span>                    n <span class="op">=</span> <span class="fl">3</span>,</span>
<span>                    prior <span class="op">=</span> <span class="fl">0.5</span>,</span>
<span>                    overdispersion.sim <span class="op">=</span> <span class="st">"estimate_k_stoch"</span>,</span>
<span>                    N <span class="op">=</span> <span class="fl">20</span><span class="op">)</span></span>
<span></span>
<span><span class="va">eval6a</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/STBP.eval.html">STBP.eval</a></span><span class="op">(</span><span class="va">test_counts1</span>,</span>
<span>                    eval.range <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">3</span>, <span class="fl">12</span><span class="op">)</span>,</span>
<span>                    n <span class="op">=</span> <span class="fl">6</span>,</span>
<span>                    prior <span class="op">=</span> <span class="fl">0.5</span>,</span>
<span>                    overdispersion.sim <span class="op">=</span> <span class="st">"estimate_k_stoch"</span>,</span>
<span>                    N <span class="op">=</span> <span class="fl">20</span><span class="op">)</span></span></code></pre></div>
<p>Here <code>eval3a</code> includes not 1 but 3 samples per sampling
bout and <code>eval6a</code> includes 6 samples. We can now visualize
how sample size within bouts affects both accuracy and efficiency:</p>
<div class="sourceCode" id="cb25"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/plot-STBP-missing-method.html">plot</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">3</span>, <span class="fl">12</span><span class="op">)</span>, <span class="va">eval1a</span><span class="op">$</span><span class="va">AvgSamples</span>, type <span class="op">=</span> <span class="st">"o"</span>, xlab <span class="op">=</span> <span class="st">"True population size"</span>,</span>
<span>      ylab <span class="op">=</span> <span class="st">"Average number of bouts"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/points.html" class="external-link">points</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">3</span>, <span class="fl">12</span><span class="op">)</span>, <span class="va">eval3a</span><span class="op">$</span><span class="va">AvgSamples</span>, type <span class="op">=</span> <span class="st">"o"</span>, pch <span class="op">=</span> <span class="fl">19</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/points.html" class="external-link">points</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">3</span>, <span class="fl">12</span><span class="op">)</span>, <span class="va">eval6a</span><span class="op">$</span><span class="va">AvgSamples</span>, type <span class="op">=</span> <span class="st">"o"</span>, pch <span class="op">=</span> <span class="fl">0</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/abline.html" class="external-link">abline</a></span><span class="op">(</span>v <span class="op">=</span> <span class="fl">9</span>, lty <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<p><img src="Seq-vignette_files/figure-html/unnamed-chunk-24-1.png" width="700"></p>
<div class="sourceCode" id="cb26"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span></span>
<span><span class="fu"><a href="../reference/plot-STBP-missing-method.html">plot</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">3</span>, <span class="fl">12</span><span class="op">)</span>, <span class="va">eval1a</span><span class="op">$</span><span class="va">AcceptRate</span>, type <span class="op">=</span> <span class="st">"o"</span>, xlab <span class="op">=</span> <span class="st">"True population size"</span>,</span>
<span>      ylab <span class="op">=</span> <span class="st">"Acceptance rate of H"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/points.html" class="external-link">points</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">3</span>, <span class="fl">12</span><span class="op">)</span>, <span class="va">eval3a</span><span class="op">$</span><span class="va">AcceptRate</span>, type <span class="op">=</span> <span class="st">"o"</span>, pch <span class="op">=</span> <span class="fl">19</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/points.html" class="external-link">points</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">3</span>, <span class="fl">12</span><span class="op">)</span>, <span class="va">eval6a</span><span class="op">$</span><span class="va">AcceptRate</span>, type <span class="op">=</span> <span class="st">"o"</span>, pch <span class="op">=</span> <span class="fl">0</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/abline.html" class="external-link">abline</a></span><span class="op">(</span>v <span class="op">=</span> <span class="fl">9</span>, lty <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<p><img src="Seq-vignette_files/figure-html/unnamed-chunk-24-2.png" width="700"></p>
<p>This very limited analysis (only 20 simulations per population
density) shows that sample sizes of 3 (filled circles) and 6 (empty
squares) outperform in accuracy and efficiency a purely sequential
design (empty circles). Some gains in accuracy can be achieved by
increasing sample size from 3 to 6.</p>
<p>Test evaluation is similar for binomial data, except that the
evaluation range is on the <code>[0, 1]</code> interval. The analog of
<code>estimate_k_stoch</code> for the binomial world for the tomato
leafminer examples is defined as (Binns et al. 2000):</p>
<div class="sourceCode" id="cb27"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">estimate_theta_stoch</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">mean</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">A</span> <span class="op">=</span> <span class="fl">780.72</span></span>
<span>  <span class="va">b</span> <span class="op">=</span> <span class="fl">1.61</span></span>
<span>  <span class="va">R</span> <span class="op">=</span> <span class="fl">10</span></span>
<span>  <span class="va">RMSE</span> <span class="op">=</span> <span class="fl">0.41</span></span>
<span>  </span>
<span>  <span class="op">(</span><span class="op">(</span><span class="fl">1</span> <span class="op">/</span> <span class="op">(</span><span class="va">R</span> <span class="op">-</span> <span class="fl">1</span><span class="op">)</span><span class="op">)</span> <span class="op">*</span> <span class="op">(</span><span class="op">(</span><span class="op">(</span><span class="va">A</span> <span class="op">*</span> <span class="va">R</span><span class="op">^</span><span class="op">(</span><span class="fl">1</span> <span class="op">-</span> <span class="va">b</span><span class="op">)</span> <span class="op">*</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">exp</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="fl">1</span>, mean <span class="op">=</span> <span class="fl">0</span>, sd <span class="op">=</span> <span class="va">RMSE</span><span class="op">)</span><span class="op">)</span><span class="op">)</span> <span class="op">/</span> <span class="op">(</span><span class="op">(</span><span class="va">mean</span> <span class="op">*</span> <span class="op">(</span><span class="fl">1</span> <span class="op">-</span> <span class="va">mean</span><span class="op">)</span><span class="op">)</span><span class="op">^</span><span class="op">(</span><span class="fl">1</span> <span class="op">-</span> <span class="va">b</span><span class="op">)</span><span class="op">)</span><span class="op">)</span> <span class="op">-</span> <span class="fl">1</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p>Now, we can run a similar analysis to compare sample sizes for a
binomial design. One important difference between binomial and count
sampling is that sample sizes for binomial designs typically require
more samples, although they are quicker and easier to examine.
Simulations within <code>STBP.eval</code> con only consider binomial
sampling with sample units or clusters made of a single observation
(<code>size = 1</code>). So, within <code>STBP.eval</code>,
<code>n = 1</code> means a single presence/absence or
infected/uninfected observation. To compensate, the argument
<code>n</code> in <code>STBP.eval</code> should reflect the total number
of observations considering all the clusters. For example, if you plan
to design a binomial sequential sampling with three clusters each of 10
observations (samples), sample size for evaluation should be set to 30,
<code>n = 30</code>. Here we test 10, 20 and 30 total observations.</p>
<div class="sourceCode" id="cb28"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">evalB10</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/STBP.eval.html">STBP.eval</a></span><span class="op">(</span><span class="va">test_bin2</span>,</span>
<span>                     eval.range <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">0.01</span>, <span class="fl">0.25</span>, <span class="fl">0.02</span><span class="op">)</span>,</span>
<span>                     n <span class="op">=</span> <span class="fl">10</span>,</span>
<span>                     prior <span class="op">=</span> <span class="fl">0.5</span>,</span>
<span>                     overdispersion.sim <span class="op">=</span> <span class="st">"estimate_theta_stoch"</span>,</span>
<span>                     N <span class="op">=</span> <span class="fl">20</span><span class="op">)</span></span>
<span></span>
<span><span class="va">evalB20</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/STBP.eval.html">STBP.eval</a></span><span class="op">(</span><span class="va">test_bin2</span>,</span>
<span>                     eval.range <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">0.01</span>, <span class="fl">0.25</span>, <span class="fl">0.02</span><span class="op">)</span>,</span>
<span>                     n <span class="op">=</span> <span class="fl">20</span>,</span>
<span>                     prior <span class="op">=</span> <span class="fl">0.5</span>,</span>
<span>                     overdispersion.sim <span class="op">=</span> <span class="st">"estimate_theta_stoch"</span>,</span>
<span>                     N <span class="op">=</span> <span class="fl">20</span><span class="op">)</span></span>
<span></span>
<span><span class="va">evalB30</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/STBP.eval.html">STBP.eval</a></span><span class="op">(</span><span class="va">test_bin2</span>,</span>
<span>                     eval.range <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">0.01</span>, <span class="fl">0.25</span>, <span class="fl">0.02</span><span class="op">)</span>,</span>
<span>                     n <span class="op">=</span> <span class="fl">30</span>,</span>
<span>                     prior <span class="op">=</span> <span class="fl">0.5</span>,</span>
<span>                     overdispersion.sim <span class="op">=</span> <span class="st">"estimate_theta_stoch"</span>,</span>
<span>                     N <span class="op">=</span> <span class="fl">20</span><span class="op">)</span></span></code></pre></div>
<p>Notice that the evaluation range are proportions on
<code>[0.01, 0.25]</code>, excluding 0 to avoid <code>warnings</code>,
and considering that H was set to H: <code>mu &gt; 0.15</code> in
<code>test_bin2</code>. We can also visualize acceptance rate of H and
average number of bouts across true incidences:</p>
<div class="sourceCode" id="cb29"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/plot-STBP-missing-method.html">plot</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">0.01</span>, <span class="fl">0.25</span>, <span class="fl">0.02</span><span class="op">)</span>, <span class="va">evalB10</span><span class="op">$</span><span class="va">AvgSamples</span>, type <span class="op">=</span> <span class="st">"o"</span>, xlab <span class="op">=</span> <span class="st">"True incidence"</span>,</span>
<span>      ylab <span class="op">=</span> <span class="st">"Average number of bouts"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/points.html" class="external-link">points</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">0.01</span>, <span class="fl">0.25</span>, <span class="fl">0.02</span><span class="op">)</span>, <span class="va">evalB20</span><span class="op">$</span><span class="va">AvgSamples</span>, type <span class="op">=</span> <span class="st">"o"</span>, pch <span class="op">=</span> <span class="fl">19</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/points.html" class="external-link">points</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">0.01</span>, <span class="fl">0.25</span>, <span class="fl">0.02</span><span class="op">)</span>, <span class="va">evalB30</span><span class="op">$</span><span class="va">AvgSamples</span>, type <span class="op">=</span> <span class="st">"o"</span>, pch <span class="op">=</span> <span class="fl">0</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/abline.html" class="external-link">abline</a></span><span class="op">(</span>v <span class="op">=</span> <span class="fl">0.15</span>, lty <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<p><img src="Seq-vignette_files/figure-html/unnamed-chunk-27-1.png" width="700"></p>
<div class="sourceCode" id="cb30"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span></span>
<span><span class="fu"><a href="../reference/plot-STBP-missing-method.html">plot</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">0.01</span>, <span class="fl">0.25</span>, <span class="fl">0.02</span><span class="op">)</span>, <span class="va">evalB10</span><span class="op">$</span><span class="va">AcceptRate</span>, type <span class="op">=</span> <span class="st">"o"</span>, xlab <span class="op">=</span> <span class="st">"True incidence"</span>,</span>
<span>      ylab <span class="op">=</span> <span class="st">"Acceptance rate of H"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/points.html" class="external-link">points</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">0.01</span>, <span class="fl">0.25</span>, <span class="fl">0.02</span><span class="op">)</span>, <span class="va">evalB20</span><span class="op">$</span><span class="va">AcceptRate</span>, type <span class="op">=</span> <span class="st">"o"</span>, pch <span class="op">=</span> <span class="fl">19</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/points.html" class="external-link">points</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">0.01</span>, <span class="fl">0.25</span>, <span class="fl">0.02</span><span class="op">)</span>, <span class="va">evalB30</span><span class="op">$</span><span class="va">AcceptRate</span>, type <span class="op">=</span> <span class="st">"o"</span>, pch <span class="op">=</span> <span class="fl">0</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/abline.html" class="external-link">abline</a></span><span class="op">(</span>v <span class="op">=</span> <span class="fl">0.15</span>, lty <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<p><img src="Seq-vignette_files/figure-html/unnamed-chunk-27-2.png" width="700"></p>
<p>Again, this is a very limited analysis made of only 20 simulations
per true incidence. However, it shows how the number of bouts required
to make a decision decreases with sample size, with designs with 10
samples (empty circles) struggling to make quick decision when incidence
is far from the the threshold of 0.15, compared with sample sizes of 20
(filled circles) and 30 (empty squares). Accuracy is also affected by
sample size with <code>n = 20</code> and <code>n = 30</code> producing
less incorrect decisions, particularly when the true incidence is below
the threshold.</p>
</div>
</div>
<div class="section level3">
<h3 id="example-3-testing-if-a-population-is-above-a-dynamic-threshold">Example 3: Testing if a population is above a dynamic threshold<a class="anchor" aria-label="anchor" href="#example-3-testing-if-a-population-is-above-a-dynamic-threshold"></a>
</h3>
<p>Sometimes hypotheses about population densities are not single
numbers, but entire population trajectories. This is the case when
monitoring programs are designed to track a target population over time
and decide as early as possible whether a management action is necessary
to prevent an outbreak. Population models often assist the prediction of
densities over time based on current densities and growth rates, so the
profile of population dynamics that result in problematic population
sizes is often known.</p>
<p>An example with real data is presented by Rincon et al. (2025). Here
we use the logistic population growth model, <code>pop.outB</code>, to
make up an outbreak population trajectory of 20 weekly population
densities that results in densities that cannot be tolerated. We will
call such trajectory <code>OB_pop &lt;- pop.outB(t = seq(1, 20))</code>,
where <code>t</code> is given in weeks.</p>
<div class="sourceCode" id="cb31"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">pop.outB</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">t</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">N0</span> <span class="op">=</span> <span class="fl">15</span></span>
<span>  <span class="va">K</span> <span class="op">=</span> <span class="fl">90</span></span>
<span>  <span class="va">r</span> <span class="op">=</span> <span class="fl">0.25</span></span>
<span>  </span>
<span>  <span class="va">K</span> <span class="op">/</span> <span class="op">(</span><span class="fl">1</span> <span class="op">+</span> <span class="op">(</span><span class="va">K</span> <span class="op">/</span> <span class="va">N0</span> <span class="op">-</span> <span class="fl">1</span><span class="op">)</span> <span class="op">*</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html" class="external-link">exp</a></span><span class="op">(</span><span class="op">-</span><span class="va">r</span> <span class="op">*</span> <span class="va">t</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="va">OB_pop</span> <span class="op">&lt;-</span> <span class="fu">pop.outB</span><span class="op">(</span>t <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">20</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="../reference/plot-STBP-missing-method.html">plot</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">20</span><span class="op">)</span>, <span class="va">OB_pop</span>, xlab <span class="op">=</span> <span class="st">"Time (weeks)"</span>, </span>
<span>     ylab  <span class="op">=</span> <span class="st">"Population density"</span>, lwd <span class="op">=</span> <span class="fl">2</span>, type <span class="op">=</span> <span class="st">"o"</span>, pch <span class="op">=</span> <span class="fl">19</span><span class="op">)</span></span></code></pre></div>
<p><img src="Seq-vignette_files/figure-html/unnamed-chunk-28-1.png" width="700"></p>
<p>The goal is to determine, with the fewest possible number of sampling
bouts collected over time, if a sampled population is consistent with
one equivalent or greater than <code>pop.outB</code>. One complication
that the threshold here is a moving target and the differences between
outbreak and non-outbreak population configurations during the first few
weeks (when we want to make an informed decision) are often tiny, but
tend to amplify over time. Thus, the test should be able to detect those
early tiny differences and produce correct early warnings.</p>
<p>Every cycle/season the population may behave differently but we can
use the outbreak configuration as a reference to quantify how severe
they are. For example, non-outbreaks are a portion of the outbreak, and
very bad seasons/cycles could even take larger population sizes than a
the reference outbreak. We can produce several variants of population
trajectories based on the outbreak:</p>
<div class="sourceCode" id="cb32"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/plot-STBP-missing-method.html">plot</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">20</span><span class="op">)</span>, <span class="va">OB_pop</span>, ylim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">95</span><span class="op">)</span>, type <span class="op">=</span> <span class="st">"o"</span>, </span>
<span>     lwd <span class="op">=</span> <span class="fl">2</span>, ylab <span class="op">=</span> <span class="st">"Population size"</span>, xlab <span class="op">=</span> <span class="st">"Time (weeks)"</span>, pch <span class="op">=</span> <span class="fl">19</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/points.html" class="external-link">points</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">20</span><span class="op">)</span>, <span class="va">OB_pop</span> <span class="op">*</span> <span class="fl">0.9</span>, type <span class="op">=</span> <span class="st">"o"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/points.html" class="external-link">points</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">20</span><span class="op">)</span>, <span class="va">OB_pop</span> <span class="op">*</span> <span class="fl">0.7</span>, type <span class="op">=</span> <span class="st">"o"</span>, pch <span class="op">=</span> <span class="fl">0</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/points.html" class="external-link">points</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">20</span><span class="op">)</span>, <span class="va">OB_pop</span> <span class="op">*</span> <span class="fl">0.5</span>, type <span class="op">=</span> <span class="st">"o"</span>, pch <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/points.html" class="external-link">points</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">20</span><span class="op">)</span>, <span class="va">OB_pop</span> <span class="op">*</span> <span class="fl">1.1</span>, type <span class="op">=</span> <span class="st">"o"</span>, pch <span class="op">=</span> <span class="fl">5</span><span class="op">)</span></span></code></pre></div>
<p><img src="Seq-vignette_files/figure-html/unnamed-chunk-29-1.png" width="700"></p>
<p>The trajectory in bold is the outbreak population configuration,
<code>OB_pop</code>, and the rest are outbreak and non-outbreak
variants. The pattern with triangles is a configuration of 50% of an
outbreak, the one with squares one of 70% of an outbreak, circles 90% of
an outbreak, and diamonds represents one that surpasses the outbreak by
10%. Modeling variants using the outbreak as a reference (with
proportions) is more realistic than varying single parameters in the
<code>pop.outB</code> function, since there are multiple mechanisms that
drive simultaneously outbreak severity. As we’ll see below, the
evaluation range to evaluate STBP for dynamic thresholds in
<code>STBP.eval</code> is provided as factors of the threshold
trajectory.</p>
<p>Like for static hypotheses, data for dynamic hypotheses come in
sequential bouts of counts or proportions with or without
overdispersion, and the data is structured in the same way. The only
difference is that true density varies over time according to the
population model. For example, data collected sequentially in bouts of
10 samples each on a population that is 70% of an outbreak ca be
generated as:</p>
<div class="sourceCode" id="cb33"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">pop70</span> <span class="op">&lt;-</span> <span class="va">OB_pop</span> <span class="op">*</span> <span class="fl">0.7</span></span>
<span><span class="va">count70</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="cn">NA</span>, <span class="fl">10</span>, <span class="fl">20</span><span class="op">)</span></span>
<span></span>
<span><span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fl">20</span><span class="op">)</span><span class="op">{</span></span>
<span>  <span class="va">count70</span><span class="op">[</span>, <span class="va">i</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/NegBinomial.html" class="external-link">rnbinom</a></span><span class="op">(</span><span class="fl">10</span>, mu <span class="op">=</span> <span class="va">pop70</span><span class="op">[</span><span class="va">i</span><span class="op">]</span>, size <span class="op">=</span> <span class="fu">estimate_k</span><span class="op">(</span><span class="va">pop70</span><span class="op">[</span><span class="va">i</span><span class="op">]</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">count70</span>, <span class="fl">3</span><span class="op">)</span> <span class="co"># only first three samples out of ten are shown</span></span>
<span><span class="co">#&gt;      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] [,14]</span></span>
<span><span class="co">#&gt; [1,]   10   18   15   18   28   36   24   17   31    52    34    58    52    43</span></span>
<span><span class="co">#&gt; [2,]   11   14   25   20   10   24   39   37   42    38    50    74    34    88</span></span>
<span><span class="co">#&gt; [3,]   21   17   19   42   19   16   27   39   50    35    61    42    56    37</span></span>
<span><span class="co">#&gt;      [,15] [,16] [,17] [,18] [,19] [,20]</span></span>
<span><span class="co">#&gt; [1,]    59    69    67    60    41    53</span></span>
<span><span class="co">#&gt; [2,]    53    45    47    61    28    69</span></span>
<span><span class="co">#&gt; [3,]    50    54    58    87    75    75</span></span></code></pre></div>
<p>Notice that we are using the same negative binomial specification of
example 2, with varying overdispersion described with the function
<code>estimate_k</code>, but a constant overdispersion could also be
used. We can visualize the sample means per sampling bout (means across
columns of <code>counts70</code>) along with the outbreak trajectory,
<code>OB_pop</code>:</p>
<div class="sourceCode" id="cb34"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/plot-STBP-missing-method.html">plot</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">20</span><span class="op">)</span>, <span class="va">OB_pop</span>, ylim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">95</span><span class="op">)</span>, type <span class="op">=</span> <span class="st">"o"</span>, </span>
<span>     lwd <span class="op">=</span> <span class="fl">2</span>, ylab <span class="op">=</span> <span class="st">"Population size"</span>, xlab <span class="op">=</span> <span class="st">"Time (weeks)"</span>, pch <span class="op">=</span> <span class="fl">19</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/points.html" class="external-link">points</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">20</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/colSums.html" class="external-link">colMeans</a></span><span class="op">(</span><span class="va">count70</span><span class="op">)</span>, type <span class="op">=</span> <span class="st">"o"</span><span class="op">)</span></span></code></pre></div>
<p><img src="Seq-vignette_files/figure-html/unnamed-chunk-31-1.png" width="700"></p>
<p>To run the test on <code>count70</code>, we only have to specify the
outbreak trajectory (not the function) in the <code>hypothesis</code>
argument of <code>stbp_composite</code>:</p>
<div class="sourceCode" id="cb35"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">test_dyn</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/stbp_composite.html">stbp_composite</a></span><span class="op">(</span>data <span class="op">=</span> <span class="va">count70</span>,</span>
<span>                           greater_than <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>                           hypothesis <span class="op">=</span> <span class="va">OB_pop</span>,</span>
<span>                           density_func <span class="op">=</span> <span class="st">"negative binomial"</span>,</span>
<span>                           overdispersion <span class="op">=</span> <span class="st">"estimate_k"</span>,</span>
<span>                           prior <span class="op">=</span> <span class="fl">0.5</span>,</span>
<span>                           lower_bnd <span class="op">=</span> <span class="fl">0</span>,</span>
<span>                           upper_bnd <span class="op">=</span> <span class="cn">Inf</span>,</span>
<span>                           lower_criterion <span class="op">=</span> <span class="fl">0.001</span>,</span>
<span>                           upper_criterion <span class="op">=</span> <span class="fl">0.999</span><span class="op">)</span></span>
<span><span class="va">test_dyn</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Sequential test of Bayesian posterior probabilities</span></span>
<span><span class="co">#&gt; Family: negative binomial</span></span>
<span><span class="co">#&gt; H: mu &gt; Trajectory =  OB_pop</span></span>
<span><span class="co">#&gt; Probability: 0.00011 from 2 sampling bouts</span></span>
<span><span class="co">#&gt; Recommendation based on provided criteria: reject H</span></span></code></pre></div>
<p>The STBP rejects H: <code>trajectory mu &gt; trajectory OB_pop</code>
after only two bouts. The procedure to test dynamic hypotheses with
binomial data is similar, except that trajectories should be provided as
proportions (incidence) and data should be structured as
<code><a href="https://rdrr.io/r/base/list.html" class="external-link">list()</a></code> of matrices with column 1 with successes and column
2 with samples.</p>
<div class="section level4">
<h4 id="test-evaluation-1">Test evaluation<a class="anchor" aria-label="anchor" href="#test-evaluation-1"></a>
</h4>
<p>STBP for dynamic hypotheses can be evaluated the same way as tests
for static hypotheses. The only difference is that
<code>eval.range</code> is provided as factors of the threshold
trajectory. For example, for <code>test_dyn</code>, the evaluation is
run on data generated for a range of percentages of
<code>OB_pop = pop.outB(seq(1, 20))</code>, such as
<code>OB_pop * 0.5</code> for 50% an outbreak, <code>OB_pop * 0.7</code>
for 70% an outbreak, or <code>OB_pop * 1.2</code> for 20% <em>above</em>
the outbreak. We can refer to these factors as “outbreak
intensities”.</p>
<div class="sourceCode" id="cb36"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">eval_dyn</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/STBP.eval.html">STBP.eval</a></span><span class="op">(</span><span class="va">test_dyn</span>,</span>
<span>                      eval.range <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">0.2</span>, <span class="fl">1.5</span>, <span class="fl">0.2</span><span class="op">)</span>,</span>
<span>                      n <span class="op">=</span> <span class="fl">10</span>,</span>
<span>                      prior <span class="op">=</span> <span class="fl">0.5</span>, </span>
<span>                      N <span class="op">=</span> <span class="fl">20</span><span class="op">)</span></span></code></pre></div>
<p>We can visualize the average number of bouts required to make a
decision and the acceptance rate of H across true outbreak
intensities.</p>
<div class="sourceCode" id="cb37"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/plot-STBP-missing-method.html">plot</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">0.2</span>, <span class="fl">1.5</span>, <span class="fl">0.2</span><span class="op">)</span>, <span class="va">eval_dyn</span><span class="op">$</span><span class="va">AvgSamples</span>, type <span class="op">=</span> <span class="st">"o"</span>, xlab <span class="op">=</span> <span class="st">"True outbreak </span></span>
<span><span class="st">     intensity"</span>, ylab <span class="op">=</span> <span class="st">"Average number of bouts"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/abline.html" class="external-link">abline</a></span><span class="op">(</span>v <span class="op">=</span> <span class="fl">1</span>, lty <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<p><img src="Seq-vignette_files/figure-html/unnamed-chunk-34-1.png" width="700"></p>
<div class="sourceCode" id="cb38"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span></span>
<span><span class="fu"><a href="../reference/plot-STBP-missing-method.html">plot</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">0.2</span>, <span class="fl">1.5</span>, <span class="fl">0.2</span><span class="op">)</span>, <span class="va">eval_dyn</span><span class="op">$</span><span class="va">AcceptRate</span>, type <span class="op">=</span> <span class="st">"o"</span>, xlab <span class="op">=</span> <span class="st">"True outbreak </span></span>
<span><span class="st">     intensity"</span>, ylab <span class="op">=</span> <span class="st">"Acceptance rate of H"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/abline.html" class="external-link">abline</a></span><span class="op">(</span>v <span class="op">=</span> <span class="fl">1</span>, lty <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<p><img src="Seq-vignette_files/figure-html/unnamed-chunk-34-2.png" width="700"></p>
<p>The pattern is similar to the one shown for static hypotheses
(example 2). Average sampling bouts peaks at the threshold (outbreak
intensity = 1) where decision-making is toughest and more samples are
required to distinguish outbreaks from non-outbreaks. Acceptance rate of
H is 0 at low outbreak intensities and reaches 1 above the threshold
(outbreak intensity = 1). Again, the value of this analysis stems from
the ability to check the balance between sampling effort and accuracy
that results from varying decision criteria (arguments
<code>lower_criterion</code> or <code>upper_criterion</code>) and
sampling size within bouts.</p>
</div>
</div>
</div>
<div class="section level2">
<h2 id="the-sequential-probability-ratio-test">2. The Sequential Probability Ratio Test<a class="anchor" aria-label="anchor" href="#the-sequential-probability-ratio-test"></a>
</h2>
<p>The SPRT was invented in the context of quality control back in the
40s, but it is widely applied in many fields, including population
management and clinical trials. In fact, there are other R packages that
implement the SPRT, particularly in the field of clinical trials (see
introduction for a list). The SPRT is popular among practitioners of
Integrated Pest Management, who are often familiar with the charts with
two parallel lines on which cumulative pest counts are overlapped to
decide if sampling should continue or if there is enough evidence to
stop and decide in favor or against the hypothesis being tested. The
SPRT has been extensively tested and it has been shown to be optimal
under a restricted range of contexts. The SPRT can be easily implemented
even without a calculator just by comparing data with stop lines “on the
fly”.</p>
<p>The main difference between STBP and SPRT is philosophical. While
STBP provides recommendations about H based on Bayesian probabilities,
SPRT does so based on likelihood ratios. Bayesian probabilities are
understood as the credibility for H to be true <em>given</em> the data,
and likelihood ratios rely on the frequency in which observations occur
in face of two competing models. For this reason, the decision criteria
for STBP (i.e., arguments <code>lower_criterion</code> and
<code>upper_criterion</code>) are not directly associated with type I
and type II error rates and the <code>stbp_simple</code> and
<code>stbp_composite</code> outputs include the final posterior
probability (credibility) for H. In SPRT, tolerable type I and type II
error rates are explicitly set as part of the test specification and the
final likelihood ratio is not as relevant since the “significance” of
the result is stated from the beginning and provided that one of the two
stop lines has been reached.</p>
<p>One important drawback of the SPRT is that it requires the
specification of two non-related hypotheses. You can’t test a single
hypothesis against its complementary, like in STBP, because the SPRT
requires two simple hypothesis to produce a probability ratio each time
new data come. Also, the SPRT can’t process group sequential data,
unless you use the mean, median or mode and in its conventional form
cannot be used to test dynamic hypotheses. If you want to use SPRT for
dynamic hypotheses, you must use a variation called Time-Sequential
Probability Ratio Test, which is not implemented in the
<code>sequential.pops</code> package yet.</p>
<div class="section level3">
<h3 id="example-4-testing-if-a-population-is-above-a-threshold">Example 4: Testing if a population is above a threshold<a class="anchor" aria-label="anchor" href="#example-4-testing-if-a-population-is-above-a-threshold"></a>
</h3>
<p>Like other sequential tests, the SPRT assist in situations where one
wants to test if a given population is above or below a threshold. The
main difference with the STBP is that SPRT is specified with two
hypotheses instead of one. There are no rules on how those hypotheses
should be stated when you only want to test a single threshold-style
hypothesis. Conventionally, they are formulated equidistant from the
threshold density, using confidence intervals for the threshold, but
there are other approaches.</p>
<p>For this example, we will use once again the case study of the tomato
leafminer in greenhouse tomatoes. Let’s assume again the economic
threshold is static (constant) at 9 larvae per plant and we want to
test, through sequential sampling, if a population has exceeded such
threshold. In the <code>sequential.pops</code> package, the same
probability distributions available for the STBP are also available for
the SPRT, except for the beta-binomial, for which stop lines have not
been derived yet.</p>
<p>Similar to the STBP, distributions without overdispersion (poisson
and binomial) are used to test and sample small population sizes. But
when population grow they start to aggregate and overdispersion becomes
a nuisance that must be accounted for by using appropriate distributions
(negative binomial). However, the to specify a SPRT the overdispersion
parameter is only used for the threshold density to calculate stop
lines. If there a function to obtain reliable values for the
overdispersion parameter based on the mean, it can be used for model
evaluation to generate more realistic data.</p>
<p>Unlike the STBP, you can specify a SPRT without data, in which case
you’ll get the a chart with the corresponding stop lines as output. For
example, if we want build a test specification for H:
<code>mu &gt; 9</code> larvae per plant, we have to provide two
hypotheses that allow for the sequential calculation of probability
ratios, so that would be H0: <code>mu = 8</code> and H1:
<code>mu = 10</code>. We also must provide a probability distribution,
an overdispersion parameter value (in case the distribution is negative
binomial), and tolerable type I (<code>alpha</code>) and type II
(<code>beta</code>) error rates:</p>
<div class="sourceCode" id="cb39"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/sprt.html">sprt</a></span><span class="op">(</span>mu0 <span class="op">=</span> <span class="fl">8</span>,</span>
<span>     mu1 <span class="op">=</span> <span class="fl">10</span>,</span>
<span>     density_func <span class="op">=</span> <span class="st">"negative binomial"</span>,</span>
<span>     overdispersion <span class="op">=</span> <span class="fu">estimate_k</span><span class="op">(</span><span class="fl">9</span><span class="op">)</span>,</span>
<span>     alpha <span class="op">=</span> <span class="fl">0.1</span>,</span>
<span>     beta <span class="op">=</span> <span class="fl">0.1</span><span class="op">)</span></span></code></pre></div>
<p><img src="Seq-vignette_files/figure-html/unnamed-chunk-35-1.png" width="700"></p>
<pre><code><span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Sequential Probability Ratio Test - Stop lines</span></span>
<span><span class="co">#&gt; Family: negative binomial</span></span>
<span><span class="co">#&gt; H0: mu = 8</span></span>
<span><span class="co">#&gt; H1: mu = 10 </span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Upper line coefficients:</span></span>
<span><span class="co">#&gt; Intercept =  28.45668</span></span>
<span><span class="co">#&gt; Slope =  8.93856</span></span>
<span><span class="co">#&gt; Lower line coefficients:</span></span>
<span><span class="co">#&gt; Intercept =  -28.45668</span></span>
<span><span class="co">#&gt; Slope =  8.93856</span></span></code></pre>
<p>Notice that no data have to be provided, and that
<code>overdispersion</code> is not a function but a value specified
through a function for the threshold density of 9 larvae per plant.
Also, notice that the output is a chart with the stop line ready to
contrast with cumulative counts and the coefficients for the stops
lines.</p>
<p>Now let’s generate some data with the same specifications as in
example 2. This is from a negative binomial distribution and the
function <code>estimate_k</code> to obtain overdispersion based on the
mean:</p>
<div class="sourceCode" id="cb41"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">counts1a</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/NegBinomial.html" class="external-link">rnbinom</a></span><span class="op">(</span><span class="fl">20</span>, mu <span class="op">=</span> <span class="fl">5</span>, size <span class="op">=</span> <span class="fu">estimate_k</span><span class="op">(</span><span class="fl">5</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">counts1a</span></span>
<span><span class="co">#&gt;  [1]  2  2  5  1  7 17  4  6  5 11  7  5  4  5  4  5  8  6  4  5</span></span></code></pre></div>
<p>This is 20 random counts from a population of 5 larvae per sample
unit (plant) in size. If we run the function <code>sprt</code> with
data, a SPRT test is performed and a new <code>"SPRT"</code> object is
created.</p>
<div class="sourceCode" id="cb42"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">testPR1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sprt.html">sprt</a></span><span class="op">(</span>data <span class="op">=</span> <span class="va">counts1a</span>,</span>
<span>                mu0 <span class="op">=</span> <span class="fl">8</span>,</span>
<span>                mu1 <span class="op">=</span> <span class="fl">10</span>,</span>
<span>                density_func <span class="op">=</span> <span class="st">"negative binomial"</span>,</span>
<span>                overdispersion <span class="op">=</span> <span class="fu">estimate_k</span><span class="op">(</span><span class="fl">9</span><span class="op">)</span>,</span>
<span>                alpha <span class="op">=</span> <span class="fl">0.1</span>,</span>
<span>                beta <span class="op">=</span> <span class="fl">0.1</span><span class="op">)</span></span>
<span><span class="va">testPR1</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Sequential Probability Ratio Test</span></span>
<span><span class="co">#&gt; Family: negative binomial</span></span>
<span><span class="co">#&gt; H0: mu = 8</span></span>
<span><span class="co">#&gt; H1: mu = 10 </span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Recommendation based on provided criteria: accept H0</span></span>
<span><span class="co">#&gt; Number of sampling bouts processed:  9</span></span></code></pre></div>
<p>The output is similar to the one generated by the functions
<code>stbp_simple</code> and <code>stbp_composite</code>. In this case,
H0 is accepted, evidence is compatible with a sampled population above
the threshold of 9 individuals per plant. In contrast to
<code>stbp_simple</code> and <code>stbp_composite</code>, the output
from <code>sprt</code> does not provide a probability and the precision
of the final decision relies on the selected values for
<code>alpha</code> and <code>beta</code>. Once again, note that
overdispersion is provided as a value through a function. There is also
a <code>plot</code> method for <code>"SPRT"</code> objects, which
overlap the stop lines with cumulative counts:</p>
<div class="sourceCode" id="cb43"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/plot-STBP-missing-method.html">plot</a></span><span class="op">(</span><span class="va">testPR1</span><span class="op">)</span></span></code></pre></div>
<p><img src="Seq-vignette_files/figure-html/unnamed-chunk-38-1.png" width="700"></p>
<p>In this case, the whole sequence of 20 counts is displayed, but the
sampling should have been terminated after the 9th bout when cumulative
counts touched the area below the lower stop line. The procedure for
binary variables is similar, but cluster sampling (i.e., the ability to
collect clusters of samples, like in the STBP) is not allowed. Instead,
only 1 and 0 values can be introduced and decisions and based on the
cumulative number of 1s across sampling bouts.</p>
<p>For example, binary data collected sequentially for a SPRT is
structured in a vector that can only contain 1 and 0. For example, we
can generate some binary data for a population with mean incidence of
<code>prob = 0.5</code>, without cluster sampling,
<code>size = 1</code>:</p>
<div class="sourceCode" id="cb44"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">binPR</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Binomial.html" class="external-link">rbinom</a></span><span class="op">(</span><span class="fl">40</span>, prob <span class="op">=</span> <span class="fl">0.5</span>, size <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span>
<span><span class="va">binPR</span></span>
<span><span class="co">#&gt;  [1] 0 1 1 1 1 0 0 1 1 1 1 0 1 0 1 0 1 1 0 0 0 1 0 0 1 0 1 0 1 0 1 1 0 1 1 1 0 0</span></span>
<span><span class="co">#&gt; [39] 0 0</span></span></code></pre></div>
<p>Again, we could get the stop lines in a chart and the corresponding
coefficients to set up a sampling plan for H: <code>mu &gt; 0.4</code>
just by specifying the test as H0: <code>mu = 0.35</code> vs. H1:
<code>mu = 0.45</code> and omiting the argument <code>data</code> in the
function <code>sprt</code>:</p>
<div class="sourceCode" id="cb45"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/sprt.html">sprt</a></span><span class="op">(</span>mu0 <span class="op">=</span> <span class="fl">0.35</span>,</span>
<span>     mu1 <span class="op">=</span> <span class="fl">0.45</span>,</span>
<span>     density_func <span class="op">=</span> <span class="st">"binomial"</span>,</span>
<span>     alpha <span class="op">=</span> <span class="fl">0.1</span>,</span>
<span>     beta <span class="op">=</span> <span class="fl">0.1</span><span class="op">)</span></span></code></pre></div>
<p><img src="Seq-vignette_files/figure-html/unnamed-chunk-40-1.png" width="700"></p>
<pre><code><span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Sequential Probability Ratio Test - Stop lines</span></span>
<span><span class="co">#&gt; Family: binomial</span></span>
<span><span class="co">#&gt; H0: mu = 0.35</span></span>
<span><span class="co">#&gt; H1: mu = 0.45 </span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Upper line coefficients:</span></span>
<span><span class="co">#&gt; Intercept =  5.251888</span></span>
<span><span class="co">#&gt; Slope =  0.3992989</span></span>
<span><span class="co">#&gt; Lower line coefficients:</span></span>
<span><span class="co">#&gt; Intercept =  -5.251888</span></span>
<span><span class="co">#&gt; Slope =  0.3992989</span></span></code></pre>
<p>and run a SPRT for the data in <code>binPR</code> as:</p>
<div class="sourceCode" id="cb47"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">testPR2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/sprt.html">sprt</a></span><span class="op">(</span>data <span class="op">=</span> <span class="va">binPR</span>,</span>
<span>                mu0 <span class="op">=</span> <span class="fl">0.35</span>,</span>
<span>                mu1 <span class="op">=</span> <span class="fl">0.45</span>,</span>
<span>                density_func <span class="op">=</span> <span class="st">"binomial"</span>,</span>
<span>                alpha <span class="op">=</span> <span class="fl">0.1</span>,</span>
<span>                beta <span class="op">=</span> <span class="fl">0.1</span><span class="op">)</span></span>
<span><span class="va">testPR2</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Sequential Probability Ratio Test</span></span>
<span><span class="co">#&gt; Family: binomial</span></span>
<span><span class="co">#&gt; H0: mu = 0.35</span></span>
<span><span class="co">#&gt; H1: mu = 0.45 </span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Recommendation based on provided criteria: accept H1</span></span>
<span><span class="co">#&gt; Number of sampling bouts processed:  34</span></span></code></pre></div>
<p>In this case, 34 binomial sampling bouts made of a single observation
were required to make a decision between H0 or H1. The object
<code>testPR2</code> can also be used to produce a chart that compares
stop lines with the cumulative data:</p>
<div class="sourceCode" id="cb48"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/plot-STBP-missing-method.html">plot</a></span><span class="op">(</span><span class="va">testPR2</span><span class="op">)</span></span></code></pre></div>
<p><img src="Seq-vignette_files/figure-html/unnamed-chunk-42-1.png" width="700"></p>
<div class="section level4">
<h4 id="test-evaluation-2">Test evaluation<a class="anchor" aria-label="anchor" href="#test-evaluation-2"></a>
</h4>
<p>Like for the STBP, the goal of evaluating SPRT is to check
specifications and adjust to achieve a nice balance between sampling
effort and precision. The procedure and requirements and outputs are
similar. For test evaluation, overdispersion for the negative binomial
can be specified as a function with or without stochasticity. The
evaluation with a constant overdispersion (as is in the model
<code>testPR1</code>) is performed with:</p>
<div class="sourceCode" id="cb49"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">evalPR1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/SPRT.eval.html">SPRT.eval</a></span><span class="op">(</span><span class="va">testPR1</span>, eval.range <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">4</span>, <span class="fl">12</span><span class="op">)</span>, N <span class="op">=</span> <span class="fl">20</span><span class="op">)</span></span></code></pre></div>
<p>Notice that there is no need to specify once more overdispersion when
it is a constant because the same use for the model is used by default.
If we wanted to add a function that describes overdipersion with added
stochasticity the scrip would be:</p>
<div class="sourceCode" id="cb50"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">evalPR1a</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/SPRT.eval.html">SPRT.eval</a></span><span class="op">(</span><span class="va">testPR1</span>, eval.range <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">4</span>, <span class="fl">12</span><span class="op">)</span>,</span>
<span>                      overdispersion.sim <span class="op">=</span> <span class="st">"estimate_k_stoch"</span>,</span>
<span>                      N <span class="op">=</span> <span class="fl">20</span><span class="op">)</span></span></code></pre></div>
<p>Now we can compare both evaluations, with and without functional
description of overdispersion with stochasticity:</p>
<div class="sourceCode" id="cb51"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/plot-STBP-missing-method.html">plot</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">4</span>, <span class="fl">12</span><span class="op">)</span>, <span class="va">evalPR1a</span><span class="op">$</span><span class="va">AvgSamples</span>, xlab <span class="op">=</span> <span class="st">"True population size"</span>,</span>
<span>     ylab <span class="op">=</span> <span class="st">"Average number of bouts"</span>, type <span class="op">=</span> <span class="st">"o"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/points.html" class="external-link">points</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">4</span>, <span class="fl">12</span><span class="op">)</span>, <span class="va">evalPR1</span><span class="op">$</span><span class="va">AvgSamples</span>, type <span class="op">=</span> <span class="st">"o"</span>, pch <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/abline.html" class="external-link">abline</a></span><span class="op">(</span>v <span class="op">=</span> <span class="fl">9</span>, lty <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<p><img src="Seq-vignette_files/figure-html/unnamed-chunk-45-1.png" width="700"></p>
<div class="sourceCode" id="cb52"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span></span>
<span><span class="fu"><a href="../reference/plot-STBP-missing-method.html">plot</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">4</span>, <span class="fl">12</span><span class="op">)</span>, <span class="va">evalPR1a</span><span class="op">$</span><span class="va">AcceptRate</span>, xlab <span class="op">=</span> <span class="st">"True population size"</span>,</span>
<span>     ylab <span class="op">=</span> <span class="st">"Acceptance rate of H1"</span>, type <span class="op">=</span> <span class="st">"o"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/points.html" class="external-link">points</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">4</span>, <span class="fl">12</span><span class="op">)</span>, <span class="va">evalPR1</span><span class="op">$</span><span class="va">AcceptRate</span>, type <span class="op">=</span> <span class="st">"o"</span>, pch <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/abline.html" class="external-link">abline</a></span><span class="op">(</span>v <span class="op">=</span> <span class="fl">9</span>, lty <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<p><img src="Seq-vignette_files/figure-html/unnamed-chunk-45-2.png" width="700"></p>
<p>Notice the the evaluation for SPRT is performed on the acceptance
rate for H1. As mentioned above, the addition of realistic descriptions
of overdispersion across count of binomial data provides a more
realistic expectation for the test when applied to real data. In the
figures produced above, triangles denote the evaluation assuming
constant overdispersion and circles with varying overdispersion and
added stochasticity. Although this is based on far too few simulations
(<code>N = 20</code>), it shows that simulations that omit the varying
nature of overdispersion underestimate the number of sampling bouts
required to make a decision and the rate of incorrect decisions,
specially when the true population size is above the threshold.</p>
<p>Evaluation of tests with binomial data is similar:</p>
<div class="sourceCode" id="cb53"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">evalPR2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/SPRT.eval.html">SPRT.eval</a></span><span class="op">(</span><span class="va">testPR2</span>, eval.range <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">0.1</span>, <span class="fl">0.8</span>, <span class="fl">0.1</span><span class="op">)</span>, N <span class="op">=</span> <span class="fl">20</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="../reference/plot-STBP-missing-method.html">plot</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">0.1</span>, <span class="fl">0.8</span>, <span class="fl">0.1</span><span class="op">)</span>, <span class="va">evalPR2</span><span class="op">$</span><span class="va">AvgSamples</span>, xlab <span class="op">=</span> <span class="st">"True incidence"</span>,</span>
<span>     ylab <span class="op">=</span> <span class="st">"Average number of bouts"</span>, type <span class="op">=</span> <span class="st">"o"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/abline.html" class="external-link">abline</a></span><span class="op">(</span>v <span class="op">=</span> <span class="fl">0.4</span>, lty <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<p><img src="Seq-vignette_files/figure-html/unnamed-chunk-46-1.png" width="700"></p>
<div class="sourceCode" id="cb54"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/plot-STBP-missing-method.html">plot</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="fl">0.1</span>, <span class="fl">0.8</span>, <span class="fl">0.1</span><span class="op">)</span>, <span class="va">evalPR2</span><span class="op">$</span><span class="va">AcceptRate</span>, xlab <span class="op">=</span> <span class="st">"True incidence"</span>,</span>
<span>     ylab <span class="op">=</span> <span class="st">"Acceptance rate of H1"</span>, type <span class="op">=</span> <span class="st">"o"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/abline.html" class="external-link">abline</a></span><span class="op">(</span>v <span class="op">=</span> <span class="fl">0.4</span>, lty <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<p><img src="Seq-vignette_files/figure-html/unnamed-chunk-46-2.png" width="700"></p>
<p>Although binomial sampling is quicker and easier, it requires
significantly more samples than count sampling and precision is often
compromised too. However, binomial sampling can be a good alternative
when the threshold population density is small [see Binns et al. (2000)
for a discussion].</p>
</div>
</div>
</div>
<div class="section level2">
<h2 id="wishlist-for-future-versions">Wishlist for future versions<a class="anchor" aria-label="anchor" href="#wishlist-for-future-versions"></a>
</h2>
<ul>
<li>Implement cluster sampling in eval</li>
<li>Include time-sequential probability ratio test for dynamic
thresholds</li>
<li>Implement cluster sampling for SPRT</li>
<li>Protocol to run eval functions faster with parallel computing</li>
</ul>
</div>
<div class="section level2">
<h2 id="cited-literature">Cited literature<a class="anchor" aria-label="anchor" href="#cited-literature"></a>
</h2>
<p>Binns, M.R., Nyrop, J.P. &amp; Werf, W.v.d. (2000) Sampling and
monitoring in crop protection: the theoretical basis for developing
practical decision guides. CABI Pub., Wallingford, Oxon, UK; New York,
N.Y (USA). 284pp.</p>
<p>Madden, L. V., Hughes, G., &amp; Bosch, F.v.d. (2007). The study of
plant disease epidemics. American Phytopathological Society. St. Paul,
MN (USA). 421pp.</p>
<p>Rincon, D.F., McCabe, I. &amp; Crowder, D.W. (2025) Sequential
testing of complementary hypotheses about population density. Methods in
Ecology and Evolution. <a href="https://doi.org/10.1111/2041-210X.70053" class="external-link uri">https://doi.org/10.1111/2041-210X.70053</a></p>
<p>Wald, A. (1945) Sequential Tests of Statistical Hypotheses. The
Annals of Mathematical Statistics 16(2): 117-186.</p>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Diego F Rincon, Izzy McCabe, David W Crowder.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.3.</p>
</div>

    </footer>
</div>





  </body>
</html>
